---
title: Einführung in die objektorientierte Programmierung
format: 
  html:
    embed-resources: true
jupyter: python3
---

Im Folgenden werden einige Grundlagen der objektorientierten Programmierung eingeführt. Es ist lediglich ein kurzer Überblick über die einige wichtige Konzepte und bei Weitem nicht vollständig.

### Grundprinzip der objektorientierten Programmierung
Die bisherigen Programme, die wir geschrieben haben, waren "prozedural" aufgebaut: Daten wurden in (lokalen oder globalen) Variablen gespeichert, und Funktionen wurden definiert, um diese Daten zu verarbeiten.

Bei komplexeren Programmen ist es häufig übersichtlicher und strukturierter, wenn Daten die die damit arbeitenden Funktionen in sogenannten "Objekten" zusammengefasst werden. Dies wird als "objektorientierte Programmierung" bezeichnet. 

Einige Fachbegriffe der objektorientierten Programmierung:

- **Klasse**: Eine Klasse ist eine Vorlage oder ein Bauplan für ein Objekt. Sie definiert die Eigenschaften (Attribute) und das Verhalten (Methoden) des Objekts.
- **Objekt**: Ein Objekt ist ein konkretes Expemplar einer Klasse, genannt *Instanz* einer Klasse. Zu einer Klasse kann es viele Objekte geben.
- **Attribut**: Ein Attribut ist eine zu einem Objekt gehörende Variable. In diesen Variablen werden die Daten des Objekts gespeichert. Häufig kann man diese Daten im Sinne von "Eigenschaften" des Objekts interpretieren.
- **Methode**: Eine Methode ist eine zu einem Objekt gehörende Funktion. In diesen Funktionen wird das Verhalten bzw. die "Fähigkeiten" des Objekts definiert.

### Bespiel: Klasse "Fraction"

Es soll eine Klasse "Fraction" definiert werden, die Brüche repräsentiert. Ein Bruch hat zwei Attribute: den Zähler und den Nenner. Fähigkeiten (Methoden) eines Bruchs können z.B. das Kürzen des Bruchs oder das Addieren mit einem anderen Bruch sein.

Es ist praktisch und übersichtlich, die Definition der Klasse in einer eigenen Datei zu speichern. Notwendig ist das allerdings nicht. Im Folgenden werden zwei Dateien verwendet:

- `fraction.py`: Enthält die Definition der Klasse `Fraction`.
- `fractest.py`: Enthält Beispiele zur Verwendung der Klasse `Fraction`.

Wir beginnen damit, die Klasse `Fraction` in der Datei `fraction.py` zu definieren:
```{python}
#| filename: fraction.py

class Fraction:
    pass
```

Damit haben wir eine Klasse mit der Bezeichnung `Fraction` definiert. Der `pass`-Befehl bedeutet, dass die Klasse noch keine Attribute oder Methoden hat.

Um diese Klasse in einer anderen Datei zu verwenden, muss sie mit dem uns bereits bekannten `import`-Befehl importiert werden. Ein Objekt der Klasse `Fraction` wird erzeugt, in dem der Klassenname wie eine Funktion aufgerufen wird und das Ergebnis einer Variablen zugewiesen wird. Dies wird als "Instanziierung" der Klasse bezeichnet.

```{python}
#| filename: fractest.py
#| eval: false
from fraction import Fraction

bruch1 = Fraction()
```


```{python}
#| filename: fractest.py
#| echo: false
bruch1 = Fraction()
```

`bruch1` ist nun ein Objekt (eine Instanz) der Klasse `Fraction`. Da die Klasse noch keine Attribute oder Methoden hat, können wir mit dem Objekt noch nichts anfangen. 

Im nächsten Schritt fügen wir der Klasse `Fraction` Attribute für den Zähler und den Nenner hinzu. Dazu definieren wir eine spezielle Methode `__init__`, die automatisch aufgerufen wird, wenn ein Objekt der Klasse erzeugt wird. In dieser Methode werden die Attribute einer Klasse angelegt.

```{python}
#| filename: fraction.py
class Fraction:
    def __init__(self, zaehler, nenner):
        self.zaehler = zaehler
        self.nenner = nenner
```

Die Methode `__init__` hat drei Parameter: `self`, `zaehler` und `nenner`. Der Parameter `self` muss immer als erster Parameter einer Methode definiert werden. Er repräsentiert das Objekt selbst und ermöglicht den Zugriff auf die Attribute und Methoden des Objekts. Die anderen beiden Parameter legen wir fest, um beim Erzeugen eines Objekts den Zähler und den Nenner angeben zu können.

Mit `self.zaehler = zaehler` und `self.nenner = nenner` werden die Attribute `zaehler` und `nenner` des Objekts angelegt und mit den Werten der Parameter `zaehler` und `nenner` belegt.

Bei der Erzeugung eines Objekts der Klasse `Fraction` müssen nun die Werte für den Zähler und den Nenner angegeben werden (die `import`-Zeile wird im Folgenden weggelassen, muss aber natürlich in der Datei `fractest.py` weiterhin stehen):
```{python}
#| filename: fractest.py
bruch1 = Fraction(3, 4)
```

Damit haben wir ein Objekt `bruch1` der Klasse `Fraction` erzeugt, bei dem die Attribute `zaehler` und `nenner` mit den Werten `3` bzw. `4` belegt sind. 

::: {.callout-note}
Beachte, dass bei der *Definition* der Methoden einer Klasse der Paramter `self` *immer* als erster Parameter angegeben werden muss. Beim *Aufruf* der Methode wird dieser Parameter jedoch *nicht* übergeben. Python sorgt automatisch dafür, dass der Parameter `self` auf das Objekt zeigt, auf dem die Methode aufgerufen wird.
:::

Auf die Attribute eines Objekts kann mit der sogenannten "Punktnotation" zugegriffen werden. Dabei wird der Name des Objekts, gefolgt von einem Punkt und dem Namen des Attributs angegeben:
```{python}
#| filename: fractest.py
bruch1 = Fraction(3, 4)
print("Zähler:", bruch1.zaehler)
print("Nenner:", bruch1.nenner)
```

Im Moment sind `zaehler` und `nenner` einfach nur Variablen, die jeden beliebigen Inhalt haben können. Sinnvoll sind jedoch nur ganze Zahlen, und der Nenner darf nicht `0` sein. Um dies sicherzustellen, fügen wir in der `__init__`-Methode eine Überprüfung der Eingabewerte hinzu:
```{python}
#| filename: fraction.py
class Fraction:
    def __init__(self, zaehler, nenner):
        if not isinstance(zaehler, int) or not isinstance(nenner, int):
            raise ValueError("Zähler und Nenner müssen ganze Zahlen sein.")
        if nenner == 0:
            raise ValueError("Der Nenner darf nicht 0 sein.")
        self.zaehler = zaehler
        self.nenner = nenner
```

Dabei verwenden wir die Funktion `isinstance`, um zu überprüfen, ob die Eingabewerte den gewünschten Typ `int` haben. Wenn die Überprüfung fehlschlägt, wird mit dem `raise`-Befehl eine sogenannte Exception erzeugt. Diese führt dazu, dass das Programm an dieser Stelle abgebrochen wird und eine Fehlermeldung ausgegeben wird.

Probieren wir es aus:
```{python}
#| filename: fractest.py
#| error: true
# Gültiger Bruch
bruch1 = Fraction(3, 4)
print("Bruch 1:", bruch1.zaehler, "/", bruch1.nenner)

# Ungültiger Bruch (Nenner ist 0)
bruch2 = Fraction(5, 0)
```

Nun können wir der Bruch-Klasse noch Methoden hinzufügen, um ihr "Fähigkeiten" zu geben. Brüche können z.B. gekürzt werden. Dazu fügen wir eine Methode `kuerzen` hinzu, die den Bruch kürzt:
```{python}
#| filename: fraction.py
import math
class Fraction:
    def __init__(self, zaehler, nenner):
        if not isinstance(zaehler, int) or not isinstance(nenner, int):
            raise ValueError("Zähler und Nenner müssen ganze Zahlen sein.")
        if nenner == 0:
            raise ValueError("Der Nenner darf nicht 0 sein.")
        self.zaehler = zaehler
        self.nenner = nenner

    def kuerzen(self):
        ggt = math.gcd(self.zaehler, self.nenner)
        self.zaehler =  self.zaehler // ggt
        self.nenner = self.nenner // ggt
```

Methoden werden wie Funktionen definiert, nur dass der erste Parameter immer `self` ist. In der Methode `kuerzen` wird der größte gemeinsame Teiler (ggT) von Zähler und Nenner mit der Funktion `math.gcd` berechnet. Anschließend werden Zähler und Nenner durch den ggT geteilt, um den Bruch zu kürzen.

Aufgerufen wird eine Methode ebenfalls mit der Punktnotation:
```{python}
#| filename: fractest.py

bruch1 = Fraction(8, 12)
print("Vor dem Kürzen:", bruch1.zaehler, "/", bruch1.nenner)
bruch1.kuerzen()
print("Nach dem Kürzen:", bruch1.zaehler, "/", bruch1.nenner)
```

Wenn mehrere Objekte einer Klasse erzeugt werden, sind sie unabhängig voneinander:
```{python}
#| filename: fractest.py

bruch1 = Fraction(8, 12)
bruch2 = Fraction(8, 12)

bruch1.kuerzen()
print("Bruch 1:", bruch1.zaehler, "/", bruch1.nenner)
print("Bruch 2:", bruch2.zaehler, "/", bruch2.nenner)
```

Als weiteres Beispiel fügen wir der Klasse `Fraction` eine Methode `multiplizieren` hinzu, die einen anderen Bruch als Parameter entgegennimmt und den aktuellen Bruch mit diesem multipliziert:
```{python}
#| filename: fraction.py
import math
class Fraction:
    def __init__(self, zaehler, nenner):
        if not isinstance(zaehler, int) or not isinstance(nenner, int):
            raise ValueError("Zähler und Nenner müssen ganze Zahlen sein.")
        if nenner == 0:
            raise ValueError("Der Nenner darf nicht 0 sein.")
        self.zaehler = zaehler
        self.nenner = nenner

    def kuerzen(self):
        ggt = math.gcd(self.zaehler, self.nenner)
        self.zaehler =  self.zaehler // ggt
        self.nenner = self.nenner // ggt

    def multiplizieren(self, anderer_bruch):
        if not isinstance(anderer_bruch, Fraction):
            raise ValueError("Der Parameter muss ein Objekt vom Typ Fraction sein.")
        self.zaehler = self.zaehler * anderer_bruch.zaehler
        self.nenner = self.nenner * anderer_bruch.nenner
        self.kuerzen()
```

Der Ergebnisbruch soll dabei automatisch gekürzt werden. Dazu rufen wir die Methode `kuerzen` am Ende der Methode `multiplizieren` auf. Man kann also auch innerhalb einer Methode einer Klasse andere Methoden derselben Klasse aufrufen, dabei muss wie bei den Attributen `self.` vorangestellt werden.

Wir testen die Methode `multiplizieren`:

```{python}
#| filename: fractest.py
bruch1 = Fraction(2, 3)
bruch2 = Fraction(4, 6)
print(f"{bruch1.zaehler}/{bruch1.nenner} * {bruch2.zaehler}/{bruch2.nenner} ergibt:")
bruch1.multiplizieren(bruch2)
print(f"{bruch1.zaehler}/{bruch1.nenner}")
```

### Übungsaufgaben

1. Füge der Klasse `Fraction` eine Methode `anzeigen` hinzu, die den Bruch in der Form "Zähler/Nenner" als String zurückgibt. 

2. Füge der Klasse `Fraction` eine Methode `addieren` hinzu, die einen anderen Bruch als Parameter entgegennimmt und den aktuellen Bruch mit diesem addiert. Der Ergebnisbruch soll automatisch gekürzt werden.

3. Füge der Klasse `Fraction` eine Methode `dividieren` hinzu, die einen anderen Bruch als Parameter entgegennimmt und den aktuellen Bruch durch diesen dividiert. Der Ergebnisbruch soll automatisch gekürzt werden. Bei einer Division durch einen Bruch mit Zähler `0` soll eine entsprechende Fehlermeldung erzeugt werden.

