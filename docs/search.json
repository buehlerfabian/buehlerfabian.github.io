[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fabian Bühler",
    "section": "",
    "text": "Hier finden sich Materialien zu meinem Unterricht im Schuljahr 2025/26 am Störck-Gymnasium in Bad Saulgau."
  },
  {
    "objectID": "pk-programmieren/UebGrundlagenLsg.html",
    "href": "pk-programmieren/UebGrundlagenLsg.html",
    "title": "Übungen/Kontrollfragen zu 01 - Grundlagen – Lösungen",
    "section": "",
    "text": "1. Aufgabe\nBei print(alter) wird der Wert der Variablen alter ausgegeben, bei print('alter') wird der Text ‘alter’ ausgegeben.\n\n\n3. Aufgabe\nEs wird 20 ausgegeben, da in der Zeile alter + 1 die Variable alter nicht verändert wird.\n\n\n4. Aufgaben\nnicht gültig sind: 2alter, mein name, mein-name\n\n\n5. Aufgabe\nname = \"Max\"\nalter = 16\nprint(f\"Ich heiße {name} und bin {alter} Jahre alt.\")\n\n\n6. Aufgabe\nanz_hamburger ist eine Variable vom Typ int. Strings und int-Variablen lassen sich nicht mit dem +-Operator verknüpfen. Das funktioniert nur, wenn alle beteiligten Variablen vom Typ str sind.\nKorrektur:\nanz_hamburger = 8\nprint(\"Ich habe \" + str(anz_hamburger) + \" Hamburger gegessen.\")\noder mit f-String:\nanz_hamburger = 8\nprint(f\"Ich habe {anz_hamburger} Hamburger gegessen.\")\n\n\n7. Aufgabe\nzahl1 = 15\nzahl2 = 4\n\nsumme = zahl1 + zahl2\ndifferenz = zahl1 - zahl2\nprodukt = zahl1 * zahl2\nquotient = zahl1 / zahl2\n\nprint(f\"Summe: {summe}\")\nprint(f\"Differenz: {differenz}\")\nprint(f\"Produkt: {produkt}\")\nprint(f\"Quotient: {quotient}\")\n\n\n8. Aufgabe\nname = input(\"Wie heißt du? \")\nlaenge = len(name)\nprint(f\"Dein Name hat {laenge} Zeichen.\")\nAlternativ ohne zusätzliche Variable:\nname = input(\"Wie heißt du? \")\nprint(f\"Dein Name hat {len(name)} Zeichen.\")\n\n\n9. Aufgabe\ngroesse = float(input(\"Wie groß bist du (in m)? \"))\ngewicht = float(input(\"Wie viel wiegst du (in kg)? \"))\n\nbmi = gewicht / (groesse ** 2)\n\nprint(f\"Dein BMI beträgt: {bmi:.2f}\")\n\n\n10. Aufgabe\nname1 = \"Anna\"\nalter1 = 23\ngroesse1 = 1.68\ngewicht1 = 65.0\nname2 = \"Berta\"\nalter2 = 30\ngroesse2 = 1.75\ngewicht2 = 70.5\nname3 = \"Clara\"\nalter3 = 27\ngroesse3 = 1.62\ngewicht3 = 55.0\n\nprint(f\"{name1:8} {alter1:5} {groesse1:7.2f} {gewicht1:8.1f}\")\nprint(f\"{name2:8} {alter2:5} {groesse2:7.2f} {gewicht2:8.1f}\")\nprint(f\"{name3:8} {alter3:5} {groesse3:7.2f} {gewicht3:8.1f}\")"
  },
  {
    "objectID": "pk-programmieren/01-grundlagen.html",
    "href": "pk-programmieren/01-grundlagen.html",
    "title": "Grundlagen",
    "section": "",
    "text": "Operator\nBedeutung\n\n\n\n\n+\nAddition\n\n\n-\nSubtraktion\n\n\n*\nMultiplikation\n\n\n/\nDivision\n\n\n//\nganzzahlige Division\n\n\n%\nModulo (Rest der Division)\n\n\n**\nPotenzierung\n\n\n\n\nprint(3 + 2)  \nprint(3 - 2)  \nprint(3 * 2)  \nprint(3 / 2)  \nprint(3 // 2)  \nprint(3 % 2)  \nprint(3**2)  \n\n5\n1\n6\n1.5\n1\n1\n9\n\n\nErzeugung von Leerzeilen: Die Zeichenkette \\n in einem String erzeugt eine neue Zeile.\n\nprint(\"Text\\nText\")\nprint(\"\\n\")\nprint(\"Text\")\n\nText\nText\n\n\nText\n\n\nReihenfolge der Operatoren: - Klammern haben Vorrang - Multiplikation vor Addition - Potenzierung vor Multiplikation vor Addition\n\nprint(3 + 2 * 5)  # Multiplikation vor Addition\nprint((3 + 2) * 5)  # Klammern haben Vorrang\nprint(3 + 2 * 5**2)  # Potenzierung vor Multiplikation vor Addition\n\n13\n25\n53\n\n\n\nDatentypen\n\n\n\nTypname\nArt der Daten\n\n\n\n\ninteger\nganze Zahlen\n\n\nfloat\nGleitkommazahlen\n\n\nString\nZeichenketten\n\n\nBoolean\nWahrheitswert (True oder False)\n\n\nNoneType\nWert None\n\n\n\n\nprint(type(42))  # Integer (Ganzzahl)\nprint(type(3.14))  # Float (Gleitkommazahl)\nprint(type(\"Hallo\"))  # String (Text)\nprint(type(True), type(False))  # Boolean (Wahrheitswert)\nprint(type(None))  # NoneType (kein Wert)\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt; &lt;class 'bool'&gt;\n&lt;class 'NoneType'&gt;\n\n\n\n\nUmgang mit Strings\n\n\n\nOperation\nCode\n\n\n\n\nKonkatenation (Verkettung)\n\"Alice\" + \"Bob\"\n\n\nWiederholung\n\"Alice\" * 3\n\n\nNeue Zeile\n\"\\n\"\n\n\nUmwandeln in Großbuchstaben\n\"...\".upper()\n\n\nUmwandeln in Kleinbuchstaben\n\"...\".lower()\n\n\nLeerzeichen entfernen am Rand\n\"...\".strip()\n\n\n\n\nprint(\"Alice\" + \"Bob\") \nprint(\"Alice \" * 3)  \nprint(\"Hallo\\nWelt\") \nprint(\"mach mich groß\".upper())\nprint(\"MACH MICH KLEIN\".lower())\nprint(\"  zuschneiden bitte  \".strip())\n\nAliceBob\nAlice Alice Alice \nHallo\nWelt\nMACH MICH GROSS\nmach mich klein\nzuschneiden bitte\n\n\nMit f-Strings kann man Python-Ausdrücke in Strings einbetten. Alle Teile, die zwischen {...} eingeschlossen sind, werden als Python-Ausdrücke ausgewertet und das Ergebnis der Auswertung an dieser Stelle in den String eingefügt.\n\nprint(f\"2 + 2 = {2 + 2}\")\n\n2 + 2 = 4\n\n\nMit len(...) kann man die Länge eines Strings ermitteln.\n\ns = \"Guten Morgen!\"\nprint(len(s))\n\n13\n\n\n\n\nVariablen verwenden\nEine Variable ist wie eine “Schachtel” im Computerspeicher, wo man Daten ablegen kann. Weißt man einem Variablennamen mit = erstmals einen Wert zu, wird die entsprechende Variable im Computerspeicher angelegt.\nEine Variable mit Namen alter wird angelegt und mit dem Wert 15 belegt:\n\nalter = 15\n\nVerwendet man im Folgenden den Namen alter, wird auf den gespeicherten Wert zugegriffen:\n\nprint(alter)\nprint(alter + 5)\n\n15\n20\n\n\nVariablen haben einen Typ, der ihrem Inhalt entspricht:\n\nprint(type(alter))\n\n&lt;class 'int'&gt;\n\n\nDer Variablentyp kann sich ändern, wenn die Variable mit einem neuen Wert belegt wird:\n\nalter = 2.5\nprint(type(alter))\n\nalter = \"fünfzehn\"\nprint(type(alter))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nFür Variablennamen gelten folgende Regeln: - Dürfen nur Buchstaben, Zahlen und Unterstriche (_) enthalten - Dürfen nicht mit einer Zahl beginnen - Dürfen nur aus einem Wort bestehen (keine Leerzeichen)\nerlaubt z.B.: mein_name, alter2, _preis\nnicht erlaubt z.B.: 2alter, mein name, mein-name\n\n\nInput-Befehl\nDer Befehl input(\"...\") gibt den angegebenen String aus und wartet anschließend auf eine Eingabe des Benutzers. Die Eingabe wird als String-Wert dem Programm zurückgegeben und kann z.B. in einer Variable abgelegt werden.\nHier wird die Eingabe des Benutzers in der Variable name abgelegt:\nname = input(\"Wie heißt du?\")\n\nname = input(\"Wie heißt du? \") # Eingabe: Dornröschen\nprint(\"Hallo \" + name + \"!\")\n\n\n\nHallo Dornröschen!\n\n\nAchtung: input() gibt immer einen String zurück.\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nprint(type(eingabe))\n\n\n\n&lt;class 'str'&gt;\n\n\nDer eine Zahl enthaltende String kann aber in einen Zahltyp (int oder float) umgewandelt werden mit int(...) oder float(...).\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nzahl = int(eingabe)\nprint(type(zahl))\nprint(zahl + 5) \n\n\n\n&lt;class 'int'&gt;\n47\n\n\nAnalog kann man auch in float oder String umwandeln:\n\nvar = float(\"42.5\")\nprint(type(var))\nzahl = 17\nprint(type(str(zahl)))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\n\nFormatierte Ausgabe mit f-Strings\nBei der Ausgabe mit f-Strings kann man Formatierungsvorgaben machen.\n\nname1 = \"Alice\"\nname2 = \"Bob\"\nname3 = \"Charlie\"\nalter1 = 15\nalter2 = 16\nalter3 = 18\ngroesse1 = 1.70\ngroesse2 = 1.85\ngroesse3 = 1.7382\n\nprint(\"Name     Alter   Größe\")\nprint(f\"{name1:8} {alter1:5d} {groesse1:7.2f}\")\nprint(f\"{name2:8} {alter2:5d} {groesse2:7.2f}\")\nprint(f\"{name3:8} {alter3:5d} {groesse3:7.2f}\")\n\nName     Alter   Größe\nAlice       15    1.70\nBob         16    1.85\nCharlie     18    1.74\n\n\nMöglichkeiten der Formatierung:\n\n\n\n\n\n\n\nFormat\nBedeutung\n\n\n\n\n:8\nmindestens 8 Zeichen breit, rechtsbündig (Standard)\n\n\n:5d\nmindestens 5 Zeichen breit, rechtsbündig, Integer (d = decimal)\n\n\n:7.2f\nmindestens 7 Zeichen breit, rechtsbündig, Fließkommazahl (f = float) mit 2 Nachkommastellen\n\n\n\nEs gibt viele weitere Formatierungsmöglichkeiten. Eine vollständige Übersicht findet man in der Python-Dokumentation:https://docs.python.org/3/library/string.html#formatspec"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html",
    "href": "pk-programmieren/03-Funktionen.html",
    "title": "Funktionen",
    "section": "",
    "text": "print(...) oder input(...) oder len(...) sind Beispiele für (bereits vorhandene) Funktionen in Python. Man benutzt Funktionen immer auf die gleiche Weise: Man schreibt den Funktionsnamen und in runden Klammern die sog. Argumente, die der Funktion mitgegeben werden.\nWas bedeutet die Formulierung “liefert … zurück” genau? Liefert eine Funktion ein Ergebnis zurück, so wird im Python-Ausdruck an der Stelle, an der die Funktion aufgerufen wird, das zurückgelieferte Ergebnis eingesetzt. Beispiel:\nDie Funktion len(\"Hallo\")+3 liefert den Wert 5 zurück. Damit wird aus dem Ausdruck len(\"Hallo\")+3 wird 5+3 und schließlich 8.\nDie Anzahl der übergebenen Argumente (auch Parameter genannt) ist unterschiedlich: es gibt Funktionen ohne Argument, mit einem Argument oder mit mehreren Argumenten. Beim Aufruf einer Funktion ohne Argument müssen trotzdem runde Klammern geschrieben werden, z.B.:"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "href": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "title": "Funktionen",
    "section": "Definition einer Funktion",
    "text": "Definition einer Funktion\nMan kann in Python eigene Funktionen definieren. Beispiel:\n\ndef schreibeHallo():\n    print(\"Hallo!\")\n    print(\"Heute ist ein schöner Tag, oder nicht?\")\n\nBei der Definition wird ein eingerückter Codeblock verwendet, analog zu den Codeblöcken, die in der Ablaufsteuerung bei if oder while verwendet werden.\nNun kann die so definierte Funktion schreibeHallo() wie alle anderen Python-Funktionen benutzt werden:\n\nprint(\"irgendein anderer Text\")\nschreibeHallo()\nprint(\"noch mehr Text\")\n\nirgendein anderer Text\nHallo!\nHeute ist ein schöner Tag, oder nicht?\nnoch mehr Text\n\n\nDie Funktion schreibeHallo() wurde ohne Argumente definiert. In diesem Fall darf man auch keines verwenden.\n\nschreibeHallo(\"Peter\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 schreibeHallo(\"Peter\")\n\nTypeError: schreibeHallo() takes 0 positional arguments but 1 was given"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "href": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "title": "Funktionen",
    "section": "Funktionsdefinition mit Argumenten",
    "text": "Funktionsdefinition mit Argumenten\nArgumente kann man bei der Definition der Funktion in den runden Klammern angeben. Dabei darf man beliebige Variablennamen verwenden.\n\ndef schreibeHallo(name):\n    print(f\"Hallo, {name}!\")\n    laenge = len(name)\n    print(f\"Dein Name ist {laenge} Buchstaben lang.\")\n\nJetzt hat schreibeHallo einen Parameter. Der muss beim Aufruf auch angegeben werden.\n\nschreibeHallo(\"Egon\")\nschreibeHallo(\"Walburga\")\nschreibeHallo()\n\nHallo, Egon!\nDein Name ist 4 Buchstaben lang.\nHallo, Walburga!\nDein Name ist 8 Buchstaben lang.\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 3\n      1 schreibeHallo(\"Egon\")\n      2 schreibeHallo(\"Walburga\")\n----&gt; 3 schreibeHallo()\n\nTypeError: schreibeHallo() missing 1 required positional argument: 'name'\n\n\n\nDie Bezeichnung name für das Argument ist eine interne Bezeichnung, die nur in der Funktionsdefinition Bedeutung hat. Außerhalb der Definition spielt diese Bezeichnung keine Rolle.\n\nmeinVorname = \"Ignatius\"\nschreibeHallo(meinVorname)\n\nHallo, Ignatius!\nDein Name ist 8 Buchstaben lang.\n\n\nMan kann auch Funktionen mit mehreren Argumenten definieren:\n\ndef schreibeHallo(name, alter):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)\nschreibeHallo(\"Anna\", 30)\nschreibeHallo(\"Opa\", 70)\n\nHi Max!\nHallo, Anna!\nGuten Tag, Opa!"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "href": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "title": "Funktionen",
    "section": "Rückgabewerte",
    "text": "Rückgabewerte\nSelbst definierte Funktionen können ebenso wie z.B. len(...) Rückgabewerte haben. Dazu verwendet man in der Funktionsdefinition die Anweisung return. Dahinter wird der Rückgabewert angegeben.\n\ndef rechteckFlaeche(breite, hoehe):\n    flaeche = breite * hoehe\n    return flaeche\n\nDie Verwendung funktioniert wie bei anderen Funktionen mit Rückgabewert auch:\n\nb = 5\nh = 10\nA = rechteckFlaeche(b, h)\nprint(f\"Die Fläche des Rechtecks mit Breite {b} und Höhe {h} ist {A}.\")\n\nDie Fläche des Rechtecks mit Breite 5 und Höhe 10 ist 50.\n\n\nMan kann in der Definition mehrere return-Anweisungen verwenden. Die Ausführung der Funktion endet mit der ersten return-Anweisung, die ausgeführt wird.\n\ndef rechteckFlaeche(breite, hoehe):\n    if breite &lt; 0 or hoehe &lt; 0:\n        return \"Ungültige Eingabe: Breite und Höhe müssen positiv sein.\"\n    flaeche = breite * hoehe\n    return flaeche\n\n\nprint(rechteckFlaeche(5, 10))\nprint(rechteckFlaeche(-5, 10))\n\n50\nUngültige Eingabe: Breite und Höhe müssen positiv sein."
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "href": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "title": "Funktionen",
    "section": "keyword-Argumente",
    "text": "keyword-Argumente\nIm Normalfall werden die Argumente einer Funktion in der Reihenfolge übergeben, wie sie in der Funktionsdefinition angegeben. In der Funktionsdefinition im Beispiel oben\ndef schreibeHallo(name, alter):\nist der erste Parameter name, der zweite alter. Die Reihenfolge, in der die Argumente beim Aufruf angegeben werden, muss dieser Reihenfolge entsprechen.\nDavon unterscheiden sich die sogenannten keyword-Argumente. Dabei bekommen die einzelnen Argumente Namen, die beim Aufruf der Funktion mit angegeben werden mussen. Dadurch kann die Reihenfolge der Argumente beim Aufruf geändert werden.\nDie obige Beispielfunktion schreibeHallo kann auch so aufgerufen werden:\n\nschreibeHallo(alter=14, name=\"Max\")\n\nHi Max!\n\n\nHier werden die Argumente name und alter explizit benannt. Dadurch ist die Reihenfolge der Argumente beim Aufruf egal.\nMan darf keyword-Argumente und normale Argumente auch mischen. Dabei müssen die normalen Argumente zuerst angegeben werden, danach die keyword-Argumente.\n\nschreibeHallo(\"Max\", alter=14)\n\nHi Max!\n\n\nVerwendet man nach einem keyword-Argument ein nicht-keyword-Argument, so führt das zu einem Fehler:\n\nschreibeHallo(name=\"Max\", alter)\n\n\n  Cell In[15], line 1\n    schreibeHallo(name=\"Max\", alter)\n                                   ^\nSyntaxError: positional argument follows keyword argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "href": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "title": "Funktionen",
    "section": "optionale Argumente und default-Werte",
    "text": "optionale Argumente und default-Werte\nEs ist möglich, in der Funktionsdefinition für Argumente default-Werte anzugeben. Diese Werte werden verwendet, wenn beim Aufruf der Funktion kein entsprechendes Argument angegeben wird.\n\ndef schreibeHallo(name, alter=30):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)   # alter wird mit 14 belegt\nschreibeHallo(\"Anna\")      # alter wird mit default-Wert 30 belegt\n\nHi Max!\nHallo, Anna!\n\n\nMan kann auch mehr als ein Argument mit einem default-Wert versehen.\ndef schreibeHallo(name=\"John\", alter=30):\n    ...\n\nschreibeHallo(\"Max\")\nschreibeHallo()\n\nHallo, Max!\nHallo, John!\n\n\nGibt es Argumente ohne default-Wert, müssen diese bei der Definition vor den Argumenten mit default-Wert angegeben werden. Folgendes führt zu einem Fehler:\ndef schreibeHallo(name=\"John\", alter):\n    ...\n\n\n\n  Cell In[20], line 1\n    def schreibeHallo(name=\"John\", alter):\n                                   ^\nSyntaxError: non-default argument follows default argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "href": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "title": "Funktionen",
    "section": "lokaler und globaler Scope",
    "text": "lokaler und globaler Scope"
  },
  {
    "objectID": "pk-programmieren/pk-prog_einfPython.html",
    "href": "pk-programmieren/pk-prog_einfPython.html",
    "title": "Einführung in Python",
    "section": "",
    "text": "1. Grundlagen\n2. Flow control\n3. Funktionen\n4. Listen"
  },
  {
    "objectID": "11imp/einf-python/04-Listen.html",
    "href": "11imp/einf-python/04-Listen.html",
    "title": "Listen",
    "section": "",
    "text": "Listen sind eine Datenstruktur, die “unter dem Dach” einer Variable mehrere Daten speichern kann. Eine Liste wird in Python mit eckigen Klammern [] definiert. Beispiel:\nmeine_liste = [3, 5, 7, 9]\nprint(meine_liste)\n\n[3, 5, 7, 9]\nDie einzelnen Elemente einer Liste werden items genannt. Die Items in einer Liste können unterschiedliche Datentypen haben:\ngemischte_liste = [42, \"Hallo\", 3.14, True]\nprint(gemischte_liste)\n\n[42, 'Hallo', 3.14, True]\nEine Liste kann auch leer sein:\nleere_liste = []\nprint(leere_liste)\n\n[]"
  },
  {
    "objectID": "11imp/einf-python/04-Listen.html#zugriff-auf-listenelemente",
    "href": "11imp/einf-python/04-Listen.html#zugriff-auf-listenelemente",
    "title": "Listen",
    "section": "Zugriff auf Listenelemente",
    "text": "Zugriff auf Listenelemente\nDie Elemente einer Liste sind durchnummeriert, beginnend bei 0. In der Liste gemischte_liste = [42, \"Hallo\", 3.14, True] aus dem obigen Beispiel hat also die folgenden Indizes:\n\nIndex 0: 42\nIndex 1: “Hallo”\nIndex 2: 3.14\nIndex 3: True\n\nMan kann auf die einzelnen Elemente einer Liste über ihren Index zugreifen, indem man den Listennamen gefolgt von eckigen Klammern mit dem Index schreibt:\n\nprint(gemischte_liste[1])  \n\nHallo\n\n\nMit [Anfangsindex:Endindex] innerhalb der eckigen Klammern kann man auch einen Ausschnitt (Slice) der Liste erhalten, d.h. alle Elemente von Anfangsindex (einschließlich) bis Endindex (ausschließlich).\ngemischte_liste[1:3] liefert die Elemente mit den Indizes 1 und 2, aber nicht das Element mit dem Endindex 3:\n\nprint(gemischte_liste[1:3]) \n\n['Hallo', 3.14]\n\n\nMan kann den Anfangs- oder Endindex auch weglassen. Wird der Anfangsindex weggelassen, so wird automatisch 0 verwendet. Wird der Endindex weggelassen, so wird automatisch das Ende der Liste verwendet:\n\nprint(gemischte_liste[:3])  \nprint(gemischte_liste[1:])   \n\n[42, 'Hallo', 3.14]\n['Hallo', 3.14, True]\n\n\nVerwendet man einen negativen Index, so wird von hinten gezählt, wobei -1 das letzte Element ist:\n\nprint(gemischte_liste[-1])\nprint(gemischte_liste[-3:])\n\nTrue\n['Hallo', 3.14, True]\n\n\nDie Länge einer Liste kann mit der Funktion len(...) (analog zur Länge eines Strings) ermittelt werden:\n\nprint(len(gemischte_liste))\n\n4"
  },
  {
    "objectID": "11imp/einf-python/04-Listen.html#list-comprehensions",
    "href": "11imp/einf-python/04-Listen.html#list-comprehensions",
    "title": "Listen",
    "section": "List comprehensions",
    "text": "List comprehensions\nEine praktische Möglichkeit, um Listen zu erstellen, sind sogenannte list comprehensions. Damit kann man auf einfache Weise Listen erzeugen, deren Elemente durch eine Regel definiert sind. Zum Beispiel:\n\nquadrate = [x**2 for x in [1,2,3,4,5]]\nprint(quadrate)\n\n[1, 4, 9, 16, 25]"
  },
  {
    "objectID": "11imp/einf-python/04-Listen.html#liste-mit-zahlenwerten-in-festem-abstand",
    "href": "11imp/einf-python/04-Listen.html#liste-mit-zahlenwerten-in-festem-abstand",
    "title": "Listen",
    "section": "Liste mit Zahlenwerten in festem Abstand",
    "text": "Liste mit Zahlenwerten in festem Abstand\nHäufig benötigt man Listen mit Zahlenwerten in einem bestimmten Bereich und mit festem Abstand (also eine arithmetische Folge). Solche Listen können mit der Funktion arange(...) aus dem Modul numpy erstellt werden. Mit from numpy import arange wird diese Funktion importiert. Dann kann man mit arange(Beginn, Ende, Schrittweite) eine Liste von Zahlenwerten erzeugen, die bei Beginn startet, bei Ende endet (ausschließlich) und die angegebene Schrittweite hat. Beispiel:\n\nimport numpy as np\n\nwerte = np.arange(0, 10, 0.5)\nprint(werte)\n\n[0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]"
  },
  {
    "objectID": "11imp/einf-python/05-matplotlib.html",
    "href": "11imp/einf-python/05-matplotlib.html",
    "title": "Einstieg in Matplotlib",
    "section": "",
    "text": "Matplotlib ist eine weit verbreitete Bibliothek in Python zur Erstellung von statischen, animierten und interaktiven Visualisierungen.\nSie wird mit dem folgenden Befehl importiert:\n\nimport matplotlib.pyplot as plt\n\nMit plt.plot(x, y) kann man ein Diagramm zu einer Wertetabelle erstellen. Dazu muss x die x-Werte und y die y-Werte jeweils in Form einer Liste enthalten.\nBeispiel: Zu folgender Wertetabelle soll ein Diagramm erstellt werden:\n\n\n\nx\ny\n\n\n\n\n1\n2\n\n\n2\n3\n\n\n3\n5\n\n\n4\n7\n\n\n\n\nimport matplotlib.pyplot as plt\nx = [1, 2, 3, 4]\ny = [2, 3, 5, 7]\nplt.plot(x, y)\nplt.show()\n\n\n\n\n\n\n\n\nDie Anweisung plt.show() sorgt dafür, dass das Diagramm angezeigt wird. Zwischen plt.plot(...) und plt.show() können weitere Anpassungen am Diagramm vorgenommen werden, z.B. Achsenbeschriftungen oder Einstellungen zur Skalierung.\nIn der Grundeinstellung werden die einzelnen Punkte mit Strecken verbunden. Will man nur einzelne Punkte, so kann man dies durch ein zusätzliches Argument 'o' beim Aufruf von plt.plot(...) erreichen:\n\nplt.plot(x, y, 'o')\nplt.show()\n\n\n\n\n\n\n\n\nIn der Matplotlib-Dokumentation sind weitere Möglichkeiten zur Gestaltung der Linien und Punkte beschrieben (runterscrollen bis zum Abschnitt “Format Strings”).\nWeitere Anpassungsmöglichkeiten:\n\nDie Achsen können mit plt.xlabel(\"x-Achse\") und plt.ylabel(\"y-Achse\") beschriftet werden.\nMit plt.title(\"Diagrammtitel\") kann ein Titel für das Diagramm gesetzt werden.\nMit plt.xlim(min, max) und plt.ylim(min, max) können die Grenzen der x- und y-Achsen festgelegt werden.\nMit plt.grid() kann ein Raster im Hintergrund des Diagramms angezeigt werden.\n\n\nplt.plot(x, y, 'o-')\nplt.xlabel(\"x-Achse\")\nplt.ylabel(\"y-Achse\")\nplt.title(\"Beispieldiagramm\")\nplt.xlim(0, 5)\nplt.ylim(0, 8)\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "11imp/einf-python/02-flow-control.html",
    "href": "11imp/einf-python/02-flow-control.html",
    "title": "Flow control",
    "section": "",
    "text": "In Programmen hat man oft “wenn … dann …” Situationen. Im “wenn”-Teil steht eine Bedingung, die entweder wahr (True) oder falsch (False) ist. Diese Bedingungen werden in Python mit boolschen Ausdrücken dargestellt.\nHäufig ergeben sich boolsche Ausdrücke mit Vergleichsoperatoren.\nprint(f\"5 == 5 ist {5 == 5}\") \nprint(f\"5 == 3 ist {5 == 3}\") \n\nprint(f\"5 != 3 ist {5 != 3}\") \nprint(f\"5 != 5 ist {5 != 5}\")\n\nprint(f\"3 &lt; 5 ist {3 &lt; 5}\")\nprint(f\"5 &lt; 5 ist {5 &lt; 5}\")\n\n5 == 5 ist True\n5 == 3 ist False\n5 != 3 ist True\n5 != 5 ist False\n3 &lt; 5 ist True\n5 &lt; 5 ist False\nVergleiche funktionieren auch mit Variablen:\na = 10\nb = 20\nprint(f\"Für a = {a} und b = {b} ist a &lt; b {a &lt; b}.\")\n\nFür a = 10 und b = 20 ist a &lt; b True.\nMan kann boolsche Werte in Variablen abspeichern:\nvergleich1 = 5 &gt; 3\nvergleich2 = 3 &lt; 1\nprint(f\"vergleich1 ist {vergleich1}, vergleich2 ist {vergleich2}\")\n\nvergleich1 ist True, vergleich2 ist False\nBoolsche Ausdrücke können mit logischen Operatoren kombiniert werden.\nprint(f\"(5 &gt; 3) and (3 &lt; 1): {(5 &gt; 3) and (3 &lt; 1)}\")  \nprint(f\"(5 &gt; 3) and (3 &gt; 1): {(5 &gt; 3) and (3 &gt; 1)}\")  \nprint(f\"(5 &gt; 3) or (3 &lt; 1): {(5 &gt; 3) or (3 &lt; 1)}\")  \nprint(f\"(5 &lt; 3) or (3 &lt; 1): {(5 &lt; 3) or (3 &lt; 1)}\")  \nprint(f\"not (5 &gt; 3): {not (5 &gt; 3)}\")  \nprint(f\"not (5 &lt; 3): {not (5 &lt; 3)}\")  \n\n(5 &gt; 3) and (3 &lt; 1): False\n(5 &gt; 3) and (3 &gt; 1): True\n(5 &gt; 3) or (3 &lt; 1): True\n(5 &lt; 3) or (3 &lt; 1): False\nnot (5 &gt; 3): False\nnot (5 &lt; 3): True\nBesonderheiten: int- und float-Typen können untereinander verglichen werden, String-Ausdrücke können nicht mit Zahlentypen verglichen werden. Jedoch können Strings untereinander verglichen werden.\nprint(f\"5 == 5.0: {5 == 5.0}\")\nprint(f\"5 == '5': {5 == '5'}\")\nprint(f\"'Hallo' == 'Hallo': {'Hallo' == 'Hallo'}\")\n\n5 == 5.0: True\n5 == '5': False\n'Hallo' == 'Hallo': True"
  },
  {
    "objectID": "11imp/einf-python/02-flow-control.html#if-anweisung",
    "href": "11imp/einf-python/02-flow-control.html#if-anweisung",
    "title": "Flow control",
    "section": "if-Anweisung",
    "text": "if-Anweisung\nDie if-Anweisung wird verwendet, um Code nur dann auszuführen, wenn eine bestimmte Bedingung erfüllt ist. Ist die Bedingung wahr (True), wird der eingerückte Codeblock ausgeführt. Ist sie falsch (False), wird der Codeblock übersprungen.\nDie Syntax lautet:\nif [boolscher Ausdruck]:\n    ...\n    ...\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nIn diesem Beispiel wird die Ausgabe nur angezeigt, wenn a tatsächlich kleiner als b ist.\n\na = 5\nb = 10\nif a &lt; b:\n    print(\"a ist kleiner als b\")\n\nif b == a:\n    print(\"b ist gleich a\")\n\na ist kleiner als b\n\n\nDie else-Anweisung wird verwendet, um einen Codeblock auszuführen, wenn die Bedingung der vorherigen if-Anweisung nicht erfüllt ist. Sie ergänzt die if-Anweisung und sorgt dafür, dass genau einer der beiden Blöcke ausgeführt wird.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\nIn diesem Beispiel wird die Ausgabe im else-Block nur angezeigt, wenn die Bedingung a &lt; b falsch ist.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\n\na ist nicht kleiner als b\n\n\nDie elif-Anweisung steht für “else if” und wird verwendet, um mehrere Bedingungen in einer if-else-Struktur zu überprüfen. Sie folgt auf eine if-Anweisung und vor einer optionalen else-Anweisung. Sobald eine Bedingung wahr ist, wird der zugehörige Codeblock ausgeführt und die restlichen Bedingungen werden übersprungen.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\nMit elif können also mehrere Alternativen übersichtlich hintereinander geprüft werden.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\n\na ist größer als b\n\n\nAchtung: Sobald eine elif-Bedingung richtig ist, wird der Rest nicht mehr geprüft:\n\na = 1000\nb = 5\nif a &gt; b:\n    print(\"a ist größer als b\")\nelif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist größer als b\n\n\nÄndert man die Reihenfolge, funktioniert es:\n\na = 1000\nb = 5\nif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelif a &gt; b:\n    print(\"a ist größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist viel größer als b"
  },
  {
    "objectID": "11imp/einf-python/02-flow-control.html#while-schleifen",
    "href": "11imp/einf-python/02-flow-control.html#while-schleifen",
    "title": "Flow control",
    "section": "While-Schleifen",
    "text": "While-Schleifen\nDie while-Schleife wird verwendet, um einen Codeblock so lange zu wiederholen, wie eine bestimmte Bedingung wahr (True) ist. Die Bedingung wird vor jedem Durchlauf überprüft. Sobald sie falsch (False) wird, endet die Schleife. Die Syntax ist:\nwhile [boolscher Ausdruck]:\n    ...\n    ...\n\neingabe = int(input(\"Was ist 5 + 3? \")) # Eingabe: 7\nwhile eingabe != 8:\n    print(\"Falsch! Versuch es noch einmal.\")\n    eingabe = int(input(\"Was ist 5 + 3? \")) # Einfabe: 8\nprint(\"Richtig!\")\n\n\n\nWas ist 5 + 3? 7\nFalsch! Versuch es noch einmal.\nWas ist 5 + 3? 8\nRichtig!\n\n\nWir suchen durch Ausprobieren die kleinste Zahl, die durch 18 und 12 teilbar ist:\n\nzahl = 1\nwhile (zahl % 18 != 0) or (zahl % 12 != 0):\n    zahl = zahl + 1\nprint(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie break-Anweisung wird verwendet, um eine Schleife vorzeitig zu beenden. Sobald break im Schleifen-Block ausgeführt wird, wird die Schleife sofort verlassen und das Programm läuft mit dem Code nach der Schleife weiter.\nTypischerweise wird break eingesetzt, wenn eine bestimmte Bedingung innerhalb der Schleife erfüllt ist und keine weiteren Durchläufe mehr nötig sind.\nBeispiel von oben in abgeänderter Form:\n\nzahl = 1\nwhile True:\n    if (zahl % 18 == 0) and (zahl % 12 == 0):\n        print(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n        break\n    zahl = zahl + 1\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie continue-Anweisung springt wieder zum Beginn der Schleife, der Rest der Anweisung wird für diesen Durchgang ausgelassen.\n\nwhile True:\n    name = input(\"Wer bist du? \") # Eingabe: Master, danach: Doctor\n    if name != \"Doctor\":\n        continue\n    print(\"Hallo Doctor! Was ist das Passwort?\")\n    passwort = input(\"Passwort: \") # Eingabe: Tardis\n    if passwort == \"Tardis\":\n        break\nprint(\"Zutritt gewährt.\")\n\n\n\nWer bist du? Master\nWer bist du? Doctor\nHallo Doctor! Was ist das Passwort? Tardis\nZutritt gewährt."
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html",
    "href": "11imp/einf-python/03-Funktionen.html",
    "title": "Funktionen",
    "section": "",
    "text": "print(...) oder input(...) oder len(...) sind Beispiele für (bereits vorhandene) Funktionen in Python. Man benutzt Funktionen immer auf die gleiche Weise: Man schreibt den Funktionsnamen und in runden Klammern die sog. Argumente, die der Funktion mitgegeben werden.\nWas bedeutet die Formulierung “liefert … zurück” genau? Liefert eine Funktion ein Ergebnis zurück, so wird im Python-Ausdruck an der Stelle, an der die Funktion aufgerufen wird, das zurückgelieferte Ergebnis eingesetzt. Beispiel:\nDie Funktion len(\"Hallo\")+3 liefert den Wert 5 zurück. Damit wird aus dem Ausdruck len(\"Hallo\")+3 wird 5+3 und schließlich 8.\nDie Anzahl der übergebenen Argumente (auch Parameter genannt) ist unterschiedlich: es gibt Funktionen ohne Argument, mit einem Argument oder mit mehreren Argumenten. Beim Aufruf einer Funktion ohne Argument müssen trotzdem runde Klammern geschrieben werden, z.B.:"
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#definition-einer-funktion",
    "href": "11imp/einf-python/03-Funktionen.html#definition-einer-funktion",
    "title": "Funktionen",
    "section": "Definition einer Funktion",
    "text": "Definition einer Funktion\nMan kann in Python eigene Funktionen definieren. Beispiel:\n\ndef schreibeHallo():\n    print(\"Hallo!\")\n    print(\"Heute ist ein schöner Tag, oder nicht?\")\n\nBei der Definition wird ein eingerückter Codeblock verwendet, analog zu den Codeblöcken, die in der Ablaufsteuerung bei if oder while verwendet werden.\nNun kann die so definierte Funktion schreibeHallo() wie alle anderen Python-Funktionen benutzt werden:\n\nprint(\"irgendein anderer Text\")\nschreibeHallo()\nprint(\"noch mehr Text\")\n\nirgendein anderer Text\nHallo!\nHeute ist ein schöner Tag, oder nicht?\nnoch mehr Text\n\n\nDie Funktion schreibeHallo() wurde ohne Argumente definiert. In diesem Fall darf man auch keines verwenden.\n\nschreibeHallo(\"Peter\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 schreibeHallo(\"Peter\")\n\nTypeError: schreibeHallo() takes 0 positional arguments but 1 was given"
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "href": "11imp/einf-python/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "title": "Funktionen",
    "section": "Funktionsdefinition mit Argumenten",
    "text": "Funktionsdefinition mit Argumenten\nArgumente kann man bei der Definition der Funktion in den runden Klammern angeben. Dabei darf man beliebige Variablennamen verwenden.\n\ndef schreibeHallo(name):\n    print(f\"Hallo, {name}!\")\n    laenge = len(name)\n    print(f\"Dein Name ist {laenge} Buchstaben lang.\")\n\nJetzt hat schreibeHallo einen Parameter. Der muss beim Aufruf auch angegeben werden.\n\nschreibeHallo(\"Egon\")\nschreibeHallo(\"Walburga\")\nschreibeHallo()\n\nHallo, Egon!\nDein Name ist 4 Buchstaben lang.\nHallo, Walburga!\nDein Name ist 8 Buchstaben lang.\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 3\n      1 schreibeHallo(\"Egon\")\n      2 schreibeHallo(\"Walburga\")\n----&gt; 3 schreibeHallo()\n\nTypeError: schreibeHallo() missing 1 required positional argument: 'name'\n\n\n\nDie Bezeichnung name für das Argument ist eine interne Bezeichnung, die nur in der Funktionsdefinition Bedeutung hat. Außerhalb der Definition spielt diese Bezeichnung keine Rolle.\n\nmeinVorname = \"Ignatius\"\nschreibeHallo(meinVorname)\n\nHallo, Ignatius!\nDein Name ist 8 Buchstaben lang.\n\n\nMan kann auch Funktionen mit mehreren Argumenten definieren:\n\ndef schreibeHallo(name, alter):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)\nschreibeHallo(\"Anna\", 30)\nschreibeHallo(\"Opa\", 70)\n\nHi Max!\nHallo, Anna!\nGuten Tag, Opa!"
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#rückgabewerte",
    "href": "11imp/einf-python/03-Funktionen.html#rückgabewerte",
    "title": "Funktionen",
    "section": "Rückgabewerte",
    "text": "Rückgabewerte\nSelbst definierte Funktionen können ebenso wie z.B. len(...) Rückgabewerte haben. Dazu verwendet man in der Funktionsdefinition die Anweisung return. Dahinter wird der Rückgabewert angegeben.\n\ndef rechteckFlaeche(breite, hoehe):\n    flaeche = breite * hoehe\n    return flaeche\n\nDie Verwendung funktioniert wie bei anderen Funktionen mit Rückgabewert auch:\n\nb = 5\nh = 10\nA = rechteckFlaeche(b, h)\nprint(f\"Die Fläche des Rechtecks mit Breite {b} und Höhe {h} ist {A}.\")\n\nDie Fläche des Rechtecks mit Breite 5 und Höhe 10 ist 50.\n\n\nMan kann in der Definition mehrere return-Anweisungen verwenden. Die Ausführung der Funktion endet mit der ersten return-Anweisung, die ausgeführt wird.\n\ndef rechteckFlaeche(breite, hoehe):\n    if breite &lt; 0 or hoehe &lt; 0:\n        return \"Ungültige Eingabe: Breite und Höhe müssen positiv sein.\"\n    flaeche = breite * hoehe\n    return flaeche\n\n\nprint(rechteckFlaeche(5, 10))\nprint(rechteckFlaeche(-5, 10))\n\n50\nUngültige Eingabe: Breite und Höhe müssen positiv sein."
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#keyword-argumente",
    "href": "11imp/einf-python/03-Funktionen.html#keyword-argumente",
    "title": "Funktionen",
    "section": "keyword-Argumente",
    "text": "keyword-Argumente\nIm Normalfall werden die Argumente einer Funktion in der Reihenfolge übergeben, wie sie in der Funktionsdefinition angegeben. In der Funktionsdefinition im Beispiel oben\ndef schreibeHallo(name, alter):\nist der erste Parameter name, der zweite alter. Die Reihenfolge, in der die Argumente beim Aufruf angegeben werden, muss dieser Reihenfolge entsprechen.\nDavon unterscheiden sich die sogenannten keyword-Argumente. Dabei bekommen die einzelnen Argumente Namen, die beim Aufruf der Funktion mit angegeben werden mussen. Dadurch kann die Reihenfolge der Argumente beim Aufruf geändert werden.\nDie obige Beispielfunktion schreibeHallo kann auch so aufgerufen werden:\n\nschreibeHallo(alter=14, name=\"Max\")\n\nHi Max!\n\n\nHier werden die Argumente name und alter explizit benannt. Dadurch ist die Reihenfolge der Argumente beim Aufruf egal.\nMan darf keyword-Argumente und normale Argumente auch mischen. Dabei müssen die normalen Argumente zuerst angegeben werden, danach die keyword-Argumente.\n\nschreibeHallo(\"Max\", alter=14)\n\nHi Max!\n\n\nVerwendet man nach einem keyword-Argument ein nicht-keyword-Argument, so führt das zu einem Fehler:\n\nschreibeHallo(name=\"Max\", alter)\n\n\n  Cell In[15], line 1\n    schreibeHallo(name=\"Max\", alter)\n                                   ^\nSyntaxError: positional argument follows keyword argument"
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#optionale-argumente-und-default-werte",
    "href": "11imp/einf-python/03-Funktionen.html#optionale-argumente-und-default-werte",
    "title": "Funktionen",
    "section": "optionale Argumente und default-Werte",
    "text": "optionale Argumente und default-Werte\nEs ist möglich, in der Funktionsdefinition für Argumente default-Werte anzugeben. Diese Werte werden verwendet, wenn beim Aufruf der Funktion kein entsprechendes Argument angegeben wird.\n\ndef schreibeHallo(name, alter=30):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)   # alter wird mit 14 belegt\nschreibeHallo(\"Anna\")      # alter wird mit default-Wert 30 belegt\n\nHi Max!\nHallo, Anna!\n\n\nMan kann auch mehr als ein Argument mit einem default-Wert versehen.\ndef schreibeHallo(name=\"John\", alter=30):\n    ...\n\nschreibeHallo(\"Max\")\nschreibeHallo()\n\nHallo, Max!\nHallo, John!\n\n\nGibt es Argumente ohne default-Wert, müssen diese bei der Definition vor den Argumenten mit default-Wert angegeben werden. Folgendes führt zu einem Fehler:\ndef schreibeHallo(name=\"John\", alter):\n    ...\n\n\n\n  Cell In[20], line 1\n    def schreibeHallo(name=\"John\", alter):\n                                   ^\nSyntaxError: non-default argument follows default argument"
  },
  {
    "objectID": "11imp/einf-python/03-Funktionen.html#lokaler-und-globaler-scope",
    "href": "11imp/einf-python/03-Funktionen.html#lokaler-und-globaler-scope",
    "title": "Funktionen",
    "section": "lokaler und globaler Scope",
    "text": "lokaler und globaler Scope"
  },
  {
    "objectID": "11imp/UebWachstumLsg.html",
    "href": "11imp/UebWachstumLsg.html",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "",
    "text": "Umformen ergibt: \\[\na_{n+1} = 0.75\\cdot a_n + 100 = a_n - 0.25\\cdot a_n + 100 = a_n + 0.25\\cdot\\left(400 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 400\\) und der Wachstumsfaktor \\(k = 0.25\\).\n\n\n\nUmformen: \\[\na_{n+1} = 0.75\\cdot a_n + 100 \\; \\Rightarrow \\; a_n = \\frac{a_{n+1} - 100}{0.75}\n\\]\n\ndef berechneVorgaenger(an):\n    return (an - 100) / 0.75\n\nn = 10\nan = 383.1\nprint(f\"a_{n} = {an}\")\nwhile n &gt; 0:\n    an = berechneVorgaenger(an)\n    n -= 1\n    print(f\"a_{n} = {an:.2f}\")\n\na_10 = 383.1\na_9 = 377.47\na_8 = 369.96\na_7 = 359.94\na_6 = 346.59\na_5 = 328.78\na_4 = 305.04\na_3 = 273.39\na_2 = 231.19\na_1 = 174.92\na_0 = 99.89\n\n\nDer Startwert ist also \\(a_0 \\approx 99.89\\)."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe",
    "href": "11imp/UebWachstumLsg.html#aufgabe",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "",
    "text": "Umformen ergibt: \\[\na_{n+1} = 0.75\\cdot a_n + 100 = a_n - 0.25\\cdot a_n + 100 = a_n + 0.25\\cdot\\left(400 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 400\\) und der Wachstumsfaktor \\(k = 0.25\\).\n\n\n\nUmformen: \\[\na_{n+1} = 0.75\\cdot a_n + 100 \\; \\Rightarrow \\; a_n = \\frac{a_{n+1} - 100}{0.75}\n\\]\n\ndef berechneVorgaenger(an):\n    return (an - 100) / 0.75\n\nn = 10\nan = 383.1\nprint(f\"a_{n} = {an}\")\nwhile n &gt; 0:\n    an = berechneVorgaenger(an)\n    n -= 1\n    print(f\"a_{n} = {an:.2f}\")\n\na_10 = 383.1\na_9 = 377.47\na_8 = 369.96\na_7 = 359.94\na_6 = 346.59\na_5 = 328.78\na_4 = 305.04\na_3 = 273.39\na_2 = 231.19\na_1 = 174.92\na_0 = 99.89\n\n\nDer Startwert ist also \\(a_0 \\approx 99.89\\)."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-1",
    "href": "11imp/UebWachstumLsg.html#aufgabe-1",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "2. Aufgabe",
    "text": "2. Aufgabe\n\na)\nRekursionsvorschrift: \\(a_{n+1} = .998\\cdot a_n + 1000\\) mit \\(a_0 = 0\\).\n\n\n\n\n\n\nHinweis\n\n\n\nIn der Aufgabenstellung ist nicht ganz eindeutig formuliert, ob zuerst die 0,2% verdunsten und dann die 1000 m3 hinzukommen oder umgekehrt. Je nachdem, wie man die Aufgabe interpretiert, ist auch die folgende Rekursionsvorschrift möglich: \\[a_{n+1} = .998\\cdot (a_n + 1000)\\]\nDiese Problematik ist eine Folge der Modellierung als diskretes Wachstum, obwohl es sich eigentlich um einen kontinuierlichen Prozess handelt.\n\n\n\n\nb)\nUmformen ergibt: \\[\na_{n+1} = .998\\cdot a_n + 1000 = a_n - 0.002\\cdot a_n + 1000 = a_n + 0.002\\cdot\\left(500000 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 500000\\) und der Wachstumsfaktor \\(k = 0.002\\).\n\n\nc)\n\ndef berechneNachfolger(an):\n    return 0.998 * an + 1000\n\nn = 0\nan = 0\nwhile an &lt; 0.25 * 500000:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Stunden sind {an:.0f} m³ im See, d.h. er ist zu {an/500000*100:.0f}% gefüllt.\")\n\nNach 144 Stunden sind 125227 m³ im See, d.h. er ist zu 25% gefüllt."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-2",
    "href": "11imp/UebWachstumLsg.html#aufgabe-2",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "3. Aufgabe",
    "text": "3. Aufgabe\n\na)\nDer Ansatz ist ein logistisches Wachstum, d.h. \\[\na_{n+1} = a_n + k\\cdot a_n\\cdot\\left(S - a_n\\right)\n\\]\nAus der Aufgabenstellung ergibt sich \\(S=9.00\\) und \\(a_0 = 0.2\\). Nach einer Woche ist \\(a_1 = 0.4\\). Damit gilt:\n\\[\n0.4 = 0.2 + k\\cdot 0.2\\cdot(9.00 - 0.2) \\;\\Rightarrow\\; k = \\frac{0.2}{0.2\\cdot 8.8} = \\frac{1}{8.8} \\approx 0.1136\n\\]\n\n\nb)\n\ndef berechneNachfolger(an):\n    return an + 0.1136 * an * (9.00 - an)\n\nn = 0\nan = 0.2\nwhile n &lt; 8:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Wochen ist die Pflanzenhöhe {an:.2f} m.\")\n\nNach 8 Wochen ist die Pflanzenhöhe 8.99 m.\n\n\n\n\nc)\n\ndef berechneNachfolger(an):\n    return an + 0.1136 * an * (9.00 - an)\n\nn = 0\nan = 0.2\nwhile an &lt; 8:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Wochen ist die Pflanzenhöhe {an:.2f} m und damit erstmalig über 8 m.\")\n\nNach 7 Wochen ist die Pflanzenhöhe 8.63 m und damit erstmalig über 8 m."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-3",
    "href": "11imp/UebWachstumLsg.html#aufgabe-3",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "4. Aufgabe",
    "text": "4. Aufgabe\n\na)\nAnsatz mit beschränktem Wachstum: \\[\na_{n+1} = a_n + k\\cdot\\left(S - a_n\\right)\n\\]\nAus der Aufgabenstellung ergibt sich \\(S=30\\) und \\(a_0 = 6\\). Nach 1 Minute ist \\(a_1 = 7.2\\). Damit gilt:\n\\[\n7.2 = 6 + k\\cdot(30 - 6) \\;\\Rightarrow\\; k = \\frac{1.2}{24} = 0.05\n\\]\n\n\nb)\n\ndef berechneNachfolger(an):\n    return an + 0.05 * (30 - an)\n\nn = 0\nan = 6\nwhile an &lt; 20:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Minuten ist die Temperatur {an:.2f} °C.\")\n\nNach 18 Minuten ist die Temperatur 20.47 °C."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-4",
    "href": "11imp/UebWachstumLsg.html#aufgabe-4",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "5. Aufgabe",
    "text": "5. Aufgabe\n\na) und b)\nEs handelt sich um ein exponentielles Wachstum mit der Rekursionsvorschrift \\(a_{n+1} = q\\cdot a_n\\). Aus der Aufgabenstellung ergibt sich \\(q = (0.5)^{0.2} \\approx 0.87055\\).\n\n\n\n\n\n\nHinweis\n\n\n\nBegründung:\nNach 5 Tagen ist die Hälfte zerfallen, d.h. \\(a_5 = \\frac 12 \\cdot a_0\\). Andererseits gilt \\(a_5 = q^5 \\cdot a_0\\). Also ist \\(q^5 = \\frac 12\\) und damit \\(q = \\left(\\frac 12\\right)^{\\frac 15}\\).\n\n\n\ndef berechneNachfolger(an):\n    return 0.87055 * an\n\nn = 0\nan = 100\nprint(f\"Tag {n}: {an} mg\")\nwhile n &lt; 10:\n    an = berechneNachfolger(an)\n    n += 1\n    print(f\"Tag {n}: {an:.2f} mg\")\n\nTag 0: 100 mg\nTag 1: 87.06 mg\nTag 2: 75.79 mg\nTag 3: 65.98 mg\nTag 4: 57.43 mg\nTag 5: 50.00 mg\nTag 6: 43.53 mg\nTag 7: 37.89 mg\nTag 8: 32.99 mg\nTag 9: 28.72 mg\nTag 10: 25.00 mg\n\n\n\n\nc)\n\ndef berechneNachfolger(an):\n    return 0.87055 * an\n\nn = 0\nan = 100\nwhile an &gt;= .01:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Tagen sind noch {an:.3f} mg übrig.\")\n\nNach 67 Tagen sind noch 0.009 mg übrig."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-5",
    "href": "11imp/UebWachstumLsg.html#aufgabe-5",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "6. Aufgabe",
    "text": "6. Aufgabe\n\na)\n\nguthaben_bank1 = 1000\nguthaben_bank2 = 1000\nguthaben_bank3 = 1000\nguthaben_bank4 = 1000\n\nmonat = 0\nwhile monat &lt; 6*12:\n    monat += 1\n    guthaben_bank3 = guthaben_bank3*1.002\n    if monat % 12 == 0:\n        guthaben_bank1 += 1000*0.024\n        guthaben_bank2 = guthaben_bank2*1.023\n        if monat &lt;= 2*12:\n            guthaben_bank4 = guthaben_bank4*1.006\n        elif monat &lt;= 4*12:\n            guthaben_bank4 = guthaben_bank4*1.012\n        else:\n            guthaben_bank4 = guthaben_bank4*1.07\n        print(f\"Ende Monat {monat}: {guthaben_bank1:.2f} €, {guthaben_bank2:.2f} €, {guthaben_bank3:.2f} €, {guthaben_bank4:.2f} €\")\n\nEnde Monat 12: 1024.00 €, 1023.00 €, 1024.27 €, 1006.00 €\nEnde Monat 24: 1048.00 €, 1046.53 €, 1049.12 €, 1012.04 €\nEnde Monat 36: 1072.00 €, 1070.60 €, 1074.58 €, 1024.18 €\nEnde Monat 48: 1096.00 €, 1095.22 €, 1100.65 €, 1036.47 €\nEnde Monat 60: 1120.00 €, 1120.41 €, 1127.36 €, 1109.02 €\nEnde Monat 72: 1144.00 €, 1146.18 €, 1154.72 €, 1186.66 €\n\n\n\n\nb)\n\nBank 1: lineares Wachstum\nBank 2: exponentielles Wachstum\nBank 3: exponentielles Wachstum\nBank 4: sonstige Wachstumsform (stückweise exponentielles Wachstum)"
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-7",
    "href": "11imp/UebWachstumLsg.html#aufgabe-7",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "Aufgabe 7",
    "text": "Aufgabe 7\n\na)\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    if monat % 12 == 0:\n        darlehen = darlehen * 1.03\n    if monat %12 == 1:\n        if darlehen &gt;= 18000:\n            darlehen -= 18000\n            bezahlt += 18000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 265 Monaten ist das Darlehen getilt.\nInsgesamt wurde 404679.12 € bezahlt.\n\n\n\n\nb)\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    darlehen *= 1.0025\n    if darlehen &gt; 1500:\n        darlehen -= 1500\n        bezahlt += 1500\n    else:\n        bezahlt += darlehen\n        darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 278 Monaten ist das Darlehen getilt.\nInsgesamt wurde 416408.40 € bezahlt.\n\n\n\n\nc)\nFall a):\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    if monat % 12 == 0:\n        darlehen = darlehen * 1.03\n    if monat %12 == 1:\n        if darlehen &gt;= 18000:\n            darlehen -= 18000\n            bezahlt += 18000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n    if monat%24 == 1:\n        if darlehen &gt;= 6000:\n            darlehen -= 6000\n            bezahlt += 6000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 217 Monaten ist das Darlehen getilt.\nInsgesamt wurde 381206.46 € bezahlt.\n\n\nFall b):\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    darlehen *= 1.0025\n    if darlehen &gt; 1500:\n        darlehen -= 1500\n        bezahlt += 1500\n    else:\n        bezahlt += darlehen\n        darlehen = 0\n    if monat%24 == 1:\n        if darlehen &gt;= 6000:\n            darlehen -= 6000\n            bezahlt += 6000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 221 Monaten ist das Darlehen getilt.\nInsgesamt wurde 390041.04 € bezahlt."
  },
  {
    "objectID": "11imp/11imp.html",
    "href": "11imp/11imp.html",
    "title": "IMP Klasse 11",
    "section": "",
    "text": "Lösungen\n\nÜbung: Programmieren einer Folge in Python\nÜbungen zu diskretem Wachstum\nÜbungen zu parametrisierten Kurven\n\n\n\nPython\n\nEinführung in Python"
  },
  {
    "objectID": "11imp/UebParameterkurveLsg.html",
    "href": "11imp/UebParameterkurveLsg.html",
    "title": "Übungen zu parametrisierten Kurven – Lösungen",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(0, 2.1, 0.1)\nx = [2*t for t in tlist]\ny = [t**2 for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(0, 2.1, 0.1)\nx = [t**2 for t in tlist]\ny = [t for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, cos, sin\ntlist = arange(0, 6.3 + 0.1, 0.1)\nx = [cos(t) for t in tlist]\ny = [2*sin(t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, cos, sin\ntlist = arange(0, 6.3 + 0.1, 0.1)\nx = [cos(t) for t in tlist]\ny = [sin(2*t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(-1.5, 1.5 + 0.1, 0.1)\nx = [t**2 for t in tlist]\ny = [t**3 for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(-1.5, 1.5 + 0.1, 0.1)\nx = [t**2 - 1 for t in tlist]\ny = [t*(t**2 - 1) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, sin, cos\ntlist = arange(-12, 12 + 0.1, 0.1)\nx = [t - sin(t) for t in tlist]\ny = [1 - cos(t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()"
  },
  {
    "objectID": "11imp/UebParameterkurveLsg.html#aufgabe",
    "href": "11imp/UebParameterkurveLsg.html#aufgabe",
    "title": "Übungen zu parametrisierten Kurven – Lösungen",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(0, 2.1, 0.1)\nx = [2*t for t in tlist]\ny = [t**2 for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(0, 2.1, 0.1)\nx = [t**2 for t in tlist]\ny = [t for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, cos, sin\ntlist = arange(0, 6.3 + 0.1, 0.1)\nx = [cos(t) for t in tlist]\ny = [2*sin(t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, cos, sin\ntlist = arange(0, 6.3 + 0.1, 0.1)\nx = [cos(t) for t in tlist]\ny = [sin(2*t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(-1.5, 1.5 + 0.1, 0.1)\nx = [t**2 for t in tlist]\ny = [t**3 for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange\ntlist = arange(-1.5, 1.5 + 0.1, 0.1)\nx = [t**2 - 1 for t in tlist]\ny = [t*(t**2 - 1) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom numpy import arange, sin, cos\ntlist = arange(-12, 12 + 0.1, 0.1)\nx = [t - sin(t) for t in tlist]\ny = [1 - cos(t) for t in tlist]\nplt.plot(x, y)\nplt.axis('equal')\nplt.show()"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html",
    "href": "11imp/UebCollatzLsg.html",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "",
    "text": "Die Prüfung, ob a_n gerade oder ungerade ist, wird am besten mit dem Modulo-Operator % durchgeführt. Der Ausdruck a_n % 2 liefert den Rest der Division von a_n durch 2. Wenn dieser Rest 0 ist, ist die Zahl gerade, andernfalls ungerade.\n\ndef collatz_next(a_n):\n    if a_n % 2 == 0:\n        return a_n // 2\n    else:\n        return 3 * a_n + 1"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe",
    "href": "11imp/UebCollatzLsg.html#aufgabe",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "",
    "text": "Die Prüfung, ob a_n gerade oder ungerade ist, wird am besten mit dem Modulo-Operator % durchgeführt. Der Ausdruck a_n % 2 liefert den Rest der Division von a_n durch 2. Wenn dieser Rest 0 ist, ist die Zahl gerade, andernfalls ungerade.\n\ndef collatz_next(a_n):\n    if a_n % 2 == 0:\n        return a_n // 2\n    else:\n        return 3 * a_n + 1"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe-1",
    "href": "11imp/UebCollatzLsg.html#aufgabe-1",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "2. Aufgabe",
    "text": "2. Aufgabe\n\ndef collatz_sequence(start_value):\n    a_n = start_value\n    while a_n != 1:\n        print(a_n)\n        a_n = collatz_next(a_n)\n    print(a_n)\n\nEs wäre auch möglich, anstelle der lokalen Variable a_n direkt mit start_value zu arbeiten. Die abschließende print(a_n)-Anweisung ist notwendig, um die 1 am Ende der Folge auch noch auszugeben."
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe-2",
    "href": "11imp/UebCollatzLsg.html#aufgabe-2",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "3. Aufgabe",
    "text": "3. Aufgabe\n\ndef collatz_length(start_value):\n    a_n = start_value\n    length = 1  # Startwert zählt als erstes Glied\n    while a_n != 1:\n        a_n = collatz_next(a_n)\n        length += 1\n    return length\n\nDer Ansatz entspricht dem der vorherigen Aufgabe, nur wird hier keine Ausgabe erzeugt, sondern statt dessen eine Zählvariable length verwendet, die bei jedem Schritt um 1 erhöht wird. Am Ende wird die Länge der Folge zurückgegeben."
  },
  {
    "objectID": "11imp/einf-python/11imp_einfPython.html",
    "href": "11imp/einf-python/11imp_einfPython.html",
    "title": "Einführung in Python (IMP Klasse 11)",
    "section": "",
    "text": "1. Grundlagen\n2. Flow control\n3. Funktionen\n4. Listen\n5. Matplotlib\n6. mehrdimensionale Listen"
  },
  {
    "objectID": "11imp/einf-python/01-grundlagen.html",
    "href": "11imp/einf-python/01-grundlagen.html",
    "title": "Grundlagen",
    "section": "",
    "text": "Operator\nBedeutung\n\n\n\n\n+\nAddition\n\n\n-\nSubtraktion\n\n\n*\nMultiplikation\n\n\n/\nDivision\n\n\n//\nganzzahlige Division\n\n\n%\nModulo (Rest der Division)\n\n\n**\nPotenzierung\n\n\n\n\nprint(3 + 2)  \nprint(3 - 2)  \nprint(3 * 2)  \nprint(3 / 2)  \nprint(3 // 2)  \nprint(3 % 2)  \nprint(3**2)  \n\n5\n1\n6\n1.5\n1\n1\n9\n\n\nErzeugung von Leerzeilen: Die Zeichenkette \\n in einem String erzeugt eine neue Zeile.\n\nprint(\"Text\\nText\")\nprint(\"\\n\")\nprint(\"Text\")\n\nText\nText\n\n\nText\n\n\nReihenfolge der Operatoren: - Klammern haben Vorrang - Multiplikation vor Addition - Potenzierung vor Multiplikation vor Addition\n\nprint(3 + 2 * 5)  # Multiplikation vor Addition\nprint((3 + 2) * 5)  # Klammern haben Vorrang\nprint(3 + 2 * 5**2)  # Potenzierung vor Multiplikation vor Addition\n\n13\n25\n53\n\n\n\nDatentypen\n\n\n\nTypname\nArt der Daten\n\n\n\n\ninteger\nganze Zahlen\n\n\nfloat\nGleitkommazahlen\n\n\nString\nZeichenketten\n\n\nBoolean\nWahrheitswert (True oder False)\n\n\nNoneType\nWert None\n\n\n\n\nprint(type(42))  # Integer (Ganzzahl)\nprint(type(3.14))  # Float (Gleitkommazahl)\nprint(type(\"Hallo\"))  # String (Text)\nprint(type(True), type(False))  # Boolean (Wahrheitswert)\nprint(type(None))  # NoneType (kein Wert)\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt; &lt;class 'bool'&gt;\n&lt;class 'NoneType'&gt;\n\n\n\n\nUmgang mit Strings\n\n\n\nOperation\nCode\n\n\n\n\nKonkatenation (Verkettung)\n\"Alice\" + \"Bob\"\n\n\nWiederholung\n\"Alice\" * 3\n\n\nNeue Zeile\n\"\\n\"\n\n\nUmwandeln in Großbuchstaben\n\"...\".upper()\n\n\nUmwandeln in Kleinbuchstaben\n\"...\".lower()\n\n\nLeerzeichen entfernen am Rand\n\"...\".strip()\n\n\n\n\nprint(\"Alice\" + \"Bob\") \nprint(\"Alice \" * 3)  \nprint(\"Hallo\\nWelt\") \nprint(\"mach mich groß\".upper())\nprint(\"MACH MICH KLEIN\".lower())\nprint(\"  zuschneiden bitte  \".strip())\n\nAliceBob\nAlice Alice Alice \nHallo\nWelt\nMACH MICH GROSS\nmach mich klein\nzuschneiden bitte\n\n\nMit f-Strings kann man Python-Ausdrücke in Strings einbetten. Alle Teile, die zwischen {...} eingeschlossen sind, werden als Python-Ausdrücke ausgewertet und das Ergebnis der Auswertung an dieser Stelle in den String eingefügt.\n\nprint(f\"2 + 2 = {2 + 2}\")\n\n2 + 2 = 4\n\n\nMit len(...) kann man die Länge eines Strings ermitteln.\n\ns = \"Guten Morgen!\"\nprint(len(s))\n\n13\n\n\n\n\nVariablen verwenden\nEine Variable ist wie eine “Schachtel” im Computerspeicher, wo man Daten ablegen kann. Weißt man einem Variablennamen mit = erstmals einen Wert zu, wird die entsprechende Variable im Computerspeicher angelegt.\nEine Variable mit Namen alter wird angelegt und mit dem Wert 15 belegt:\n\nalter = 15\n\nVerwendet man im Folgenden den Namen alter, wird auf den gespeicherten Wert zugegriffen:\n\nprint(alter)\nprint(alter + 5)\n\n15\n20\n\n\nVariablen haben einen Typ, der ihrem Inhalt entspricht:\n\nprint(type(alter))\n\n&lt;class 'int'&gt;\n\n\nDer Variablentyp kann sich ändern, wenn die Variable mit einem neuen Wert belegt wird:\n\nalter = 2.5\nprint(type(alter))\n\nalter = \"fünfzehn\"\nprint(type(alter))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nFür Variablennamen gelten folgende Regeln: - Dürfen nur Buchstaben, Zahlen und Unterstriche (_) enthalten - Dürfen nicht mit einer Zahl beginnen - Dürfen nur aus einem Wort bestehen (keine Leerzeichen)\nerlaubt z.B.: mein_name, alter2, _preis\nnicht erlaubt z.B.: 2alter, mein name, mein-name\n\n\nInput-Befehl\nDer Befehl input(\"...\") gibt den angegebenen String aus und wartet anschließend auf eine Eingabe des Benutzers. Die Eingabe wird als String-Wert dem Programm zurückgegeben und kann z.B. in einer Variable abgelegt werden.\nHier wird die Eingabe des Benutzers in der Variable name abgelegt:\nname = input(\"Wie heißt du?\")\n\nname = input(\"Wie heißt du? \") # Eingabe: Dornröschen\nprint(\"Hallo \" + name + \"!\")\n\n\n\nHallo Dornröschen!\n\n\nAchtung: input() gibt immer einen String zurück.\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nprint(type(eingabe))\n\n\n\n&lt;class 'str'&gt;\n\n\nDer eine Zahl enthaltende String kann aber in einen Zahltyp (int oder float) umgewandelt werden mit int(...) oder float(...).\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nzahl = int(eingabe)\nprint(type(zahl))\nprint(zahl + 5) \n\n\n\n&lt;class 'int'&gt;\n47\n\n\nAnalog kann man auch in float oder String umwandeln:\n\nvar = float(\"42.5\")\nprint(type(var))\nzahl = 17\nprint(type(str(zahl)))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\n\nFormatierte Ausgabe mit f-Strings\nBei der Ausgabe mit f-Strings kann man Formatierungsvorgaben machen.\n\nname1 = \"Alice\"\nname2 = \"Bob\"\nname3 = \"Charlie\"\nalter1 = 15\nalter2 = 16\nalter3 = 18\ngroesse1 = 1.70\ngroesse2 = 1.85\ngroesse3 = 1.7382\n\nprint(\"Name     Alter   Größe\")\nprint(f\"{name1:8} {alter1:5d} {groesse1:7.2f}\")\nprint(f\"{name2:8} {alter2:5d} {groesse2:7.2f}\")\nprint(f\"{name3:8} {alter3:5d} {groesse3:7.2f}\")\n\nName     Alter   Größe\nAlice       15    1.70\nBob         16    1.85\nCharlie     18    1.74\n\n\nMöglichkeiten der Formatierung:\n\n\n\n\n\n\n\nFormat\nBedeutung\n\n\n\n\n:8\nmindestens 8 Zeichen breit, rechtsbündig (Standard)\n\n\n:5d\nmindestens 5 Zeichen breit, rechtsbündig, Integer (d = decimal)\n\n\n:7.2f\nmindestens 7 Zeichen breit, rechtsbündig, Fließkommazahl (f = float) mit 2 Nachkommastellen\n\n\n\nEs gibt viele weitere Formatierungsmöglichkeiten. Eine vollständige Übersicht findet man in der Python-Dokumentation:https://docs.python.org/3/library/string.html#formatspec"
  },
  {
    "objectID": "11imp/einf-python/06-mehrdimListen.html",
    "href": "11imp/einf-python/06-mehrdimListen.html",
    "title": "mehrdimensionale Listen (Arrays)",
    "section": "",
    "text": "In vielen Situationen hat man Daten, die eine mehrdimensionale Struktur besitzen. Zum Beispiel können Messwerte in einer Tabelle organisiert sein, die Zeilen (verschiedene Messzeitpunkte) und Spalten (gemessene Größen) besitzt:\n\n\n\nZeit\nSpannung\nStromstärke\n\n\n\n\n0 s\n20 V\n30 A\n\n\n1 s\n21 V\n32 A\n\n\n2 s\n21.5 V\n31 A\n\n\n\nIn Python können solche Datenstrukturen mit mehrdimensionalen Listen dargestellt werden. Dabei macht man sich zunutze, dass die Elemente einer Liste einen beliebigen Datentyp haben können, also auch selbst wieder Listen sein können:\n\nmesswerte = [\n    [0, 20, 30],\n    [1, 21, 32],\n    [2, 21.5, 31]\n]\nprint(messwerte)\n\n[[0, 20, 30], [1, 21, 32], [2, 21.5, 31]]\n\n\nHier ist das erste Element der Liste messwerte selbst wieder eine Liste, nämlich die Liste [0, 20, 30], die die Messwerte zur Zeit 0 s enthält:\n\nprint(messwerte[0])\n\n[0, 20, 30]\n\n\nMöchte man davon jetzt den Spannungswert, braucht man das Element mit Index 1 der Liste messwerte[0], also messwerte[0][1]:\n\nprint(messwerte[0][1])\n\n20\n\n\nMöchte man eine Liste aller Spannungswerte erhalten, so kann man dafür eine list comprehension verwenden:\n\nspannungen = [reihe[1] for reihe in messwerte]\nprint(spannungen)\n\n[20, 21, 21.5]"
  },
  {
    "objectID": "11imp/einf-python/06-mehrdimListen.html#listen-von-listen",
    "href": "11imp/einf-python/06-mehrdimListen.html#listen-von-listen",
    "title": "mehrdimensionale Listen (Arrays)",
    "section": "",
    "text": "In vielen Situationen hat man Daten, die eine mehrdimensionale Struktur besitzen. Zum Beispiel können Messwerte in einer Tabelle organisiert sein, die Zeilen (verschiedene Messzeitpunkte) und Spalten (gemessene Größen) besitzt:\n\n\n\nZeit\nSpannung\nStromstärke\n\n\n\n\n0 s\n20 V\n30 A\n\n\n1 s\n21 V\n32 A\n\n\n2 s\n21.5 V\n31 A\n\n\n\nIn Python können solche Datenstrukturen mit mehrdimensionalen Listen dargestellt werden. Dabei macht man sich zunutze, dass die Elemente einer Liste einen beliebigen Datentyp haben können, also auch selbst wieder Listen sein können:\n\nmesswerte = [\n    [0, 20, 30],\n    [1, 21, 32],\n    [2, 21.5, 31]\n]\nprint(messwerte)\n\n[[0, 20, 30], [1, 21, 32], [2, 21.5, 31]]\n\n\nHier ist das erste Element der Liste messwerte selbst wieder eine Liste, nämlich die Liste [0, 20, 30], die die Messwerte zur Zeit 0 s enthält:\n\nprint(messwerte[0])\n\n[0, 20, 30]\n\n\nMöchte man davon jetzt den Spannungswert, braucht man das Element mit Index 1 der Liste messwerte[0], also messwerte[0][1]:\n\nprint(messwerte[0][1])\n\n20\n\n\nMöchte man eine Liste aller Spannungswerte erhalten, so kann man dafür eine list comprehension verwenden:\n\nspannungen = [reihe[1] for reihe in messwerte]\nprint(spannungen)\n\n[20, 21, 21.5]"
  },
  {
    "objectID": "11imp/einf-python/06-mehrdimListen.html#numpy-arrays",
    "href": "11imp/einf-python/06-mehrdimListen.html#numpy-arrays",
    "title": "mehrdimensionale Listen (Arrays)",
    "section": "NumPy-Arrays",
    "text": "NumPy-Arrays\nDie Numpy-Bibliothek bietet ergänzende Möglichkeiten, um mit mehrdimensionalen Datenstrukturen zu arbeiten.\nEin Numpy-Array kann aus einer Liste erzeugt werden:\n\nimport numpy as np\nmesswerte_array = np.array(messwerte)\nprint(messwerte_array)\n\n[[ 0.  20.  30. ]\n [ 1.  21.  32. ]\n [ 2.  21.5 31. ]]\n\n\nMan sieht, dass die Ausgabe jetzt in Zeilen und Spalten formatiert ist, was die Übersichtlichkeit erhöht.\nAuf ein Element eines Numpy-Arrays kann man genauso zugreifen wie bei einer Liste von Listen:\n\nprint(messwerte_array[0][1])  \n\n20.0\n\n\nFür Numpy-Arrays gibt es jedoch auch eine alternative, kompaktere Notation mit Kommas:\n\nprint(messwerte_array[0, 1])  \n\n20.0\n\n\nEine ganze Spalte zu extrahieren geht mit Numpy-Array ebenfalls einfacher:\n\nspannungen_array = messwerte_array[:, 1]\nprint(spannungen_array)\n\n[20.  21.  21.5]\n\n\nHierbei steht der Doppelpunkt : für 0:len(messwerte_array) (d.h. alle Zeilen) und die 1 für die zweite Spalte (Index 1)."
  },
  {
    "objectID": "11imp/einf-python/06-mehrdimListen.html#broadcasting-bei-numpy-arrays",
    "href": "11imp/einf-python/06-mehrdimListen.html#broadcasting-bei-numpy-arrays",
    "title": "mehrdimensionale Listen (Arrays)",
    "section": "Broadcasting bei Numpy-Arrays",
    "text": "Broadcasting bei Numpy-Arrays\nBei Python-Listen haben die Rechenoperatoren in der Regel keine arithmetische Bedeutung:\n\na = [1, 2, 3]\nb = [4, 5, 6]\nprint(a + b)  # Verkettung der Listen\nprint(a * 2)  # Wiederholung der Liste\n\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 1, 2, 3]\n\n\nBei Numpy-Arrays hingegen sind die Rechenoperatoren arithmetisch definiert:\n\na_array = np.array(a)\nb_array = np.array(b)\nprint(a_array + b_array)  # Elementweise Addition\nprint(a_array * 2)        # Elementweise Multiplikation\n\n[5 7 9]\n[2 4 6]\n\n\nHierbei wird bei der Addition jedes Element von a_array mit dem entsprechenden Element von b_array addiert, und bei der Multiplikation wird jedes Element von a_array mit 2 multipliziert (das nennt man Broadcasting)."
  },
  {
    "objectID": "11imp/einf-python/06-mehrdimListen.html#tricks-und-beispiele",
    "href": "11imp/einf-python/06-mehrdimListen.html#tricks-und-beispiele",
    "title": "mehrdimensionale Listen (Arrays)",
    "section": "Tricks und Beispiele",
    "text": "Tricks und Beispiele\nEin Numpy-Array einer bestimmten Größe mit Nullen erzeugen:\n\nnull_tabelle = np.zeros((3, 4))  # 3 Zeilen, 4 Spalten\nprint(null_tabelle)\n\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n\n\nEbenso kann man mit python np.ones((3, 4)) ein Array mit Einsen erzeugen.\nMit Hilfe von Broadcasting kann man dann alle Werte oder einzelne Bereiche ersetzen:\n\nnull_tabelle[:, :] = 5  # Alle Werte auf 5 setzen\nprint(null_tabelle)\n\n[[5. 5. 5. 5.]\n [5. 5. 5. 5.]\n [5. 5. 5. 5.]]\n\n\n\nnull_tabelle[1, :] = [1, 2, 3, 4]  # Zweite Zeile ersetzen\nprint(null_tabelle)\n\n[[5. 5. 5. 5.]\n [1. 2. 3. 4.]\n [5. 5. 5. 5.]]\n\n\n\nnull_tabelle[:, 2] = [10, 20, 30]  # Dritte Spalte ersetzen\nnull_tabelle[:, 3] = 42  # Vierte Spalte ersetzen\nprint(null_tabelle)\n\n[[ 5.  5. 10. 42.]\n [ 1.  2. 20. 42.]\n [ 5.  5. 30. 42.]]\n\n\nFür komplexere Operationen können auch Schleifen verwendet werden. Das folgende Programm erstellt eine Multiplikationstabelle:\n\nmultiplikationstabelle = np.zeros((10, 10))\n\nfor i in range(10):\n    for j in range(10):\n        multiplikationstabelle[i, j] = (i+1) * (j+1)\n\nprint(multiplikationstabelle)\n\n[[  1.   2.   3.   4.   5.   6.   7.   8.   9.  10.]\n [  2.   4.   6.   8.  10.  12.  14.  16.  18.  20.]\n [  3.   6.   9.  12.  15.  18.  21.  24.  27.  30.]\n [  4.   8.  12.  16.  20.  24.  28.  32.  36.  40.]\n [  5.  10.  15.  20.  25.  30.  35.  40.  45.  50.]\n [  6.  12.  18.  24.  30.  36.  42.  48.  54.  60.]\n [  7.  14.  21.  28.  35.  42.  49.  56.  63.  70.]\n [  8.  16.  24.  32.  40.  48.  56.  64.  72.  80.]\n [  9.  18.  27.  36.  45.  54.  63.  72.  81.  90.]\n [ 10.  20.  30.  40.  50.  60.  70.  80.  90. 100.]]"
  },
  {
    "objectID": "pk-programmieren/UebFlowControlLsg.html",
    "href": "pk-programmieren/UebFlowControlLsg.html",
    "title": "Übungen/Kontrollfragen zu 02 - Flow control – Lösungen",
    "section": "",
    "text": "groesse = float(input(\"Wie groß bist du (in m)? \"))\ngewicht = float(input(\"Wie viel wiegst du (in kg)? \"))\n\nbmi = gewicht / (groesse ** 2)\n\nprint(f\"Dein BMI beträgt: {bmi:.2f}\")\n\n# Gewichtsklasse bestimmen\nif bmi &lt; 16.5:\n    print(\"Gewichtsklasse: starkes Untergewicht\")\nelif bmi &lt; 18.5:\n    print(\"Gewichtsklasse: Untergewicht\")\nelif bmi &lt; 25:\n    print(\"Gewichtsklasse: Normalgewicht\")\nelif bmi &lt; 30:\n    print(\"Gewichtsklasse: Übergewicht\")\nelse:\n    print(\"Gewichtsklasse: starkes Übergewicht\")"
  },
  {
    "objectID": "pk-programmieren/UebFlowControlLsg.html#a",
    "href": "pk-programmieren/UebFlowControlLsg.html#a",
    "title": "Übungen/Kontrollfragen zu 02 - Flow control – Lösungen",
    "section": "a)",
    "text": "a)\na = int(input(\"Gib die erste Zahl ein: \"))\nb = int(input(\"Gib die zweite Zahl ein: \"))\n\nwhile b &gt; 0:\n    h = a % b  \n    a = b\n    b = h\n\nprint(f\"Der größte gemeinsame Teiler ist: {a}\")"
  },
  {
    "objectID": "pk-programmieren/UebFlowControlLsg.html#b",
    "href": "pk-programmieren/UebFlowControlLsg.html#b",
    "title": "Übungen/Kontrollfragen zu 02 - Flow control – Lösungen",
    "section": "b)",
    "text": "b)\nzaehler = int(input(\"Gib den Zähler ein: \"))\nnenner = int(input(\"Gib den Nenner ein: \"))\n\na = zaehler\nb = nenner\nwhile b &gt; 0:\n    h = a % b\n    a = b\n    b = h\n\nggt = a  \n\ngekuerzter_zaehler = zaehler // ggt\ngekuerzter_nenner = nenner // ggt\n\nprint(f\"Gekürzter Bruch: {gekuerzter_zaehler}/{gekuerzter_nenner}\")"
  },
  {
    "objectID": "pk-programmieren/UebListeLsg.html",
    "href": "pk-programmieren/UebListeLsg.html",
    "title": "Übungen/Kontrollfragen zu 01 - Grundlagen – Lösungen",
    "section": "",
    "text": "1. Aufgabe\n\nliste = [2, 17, 3, 8, 16, 32, -5, 20, 5, 10, 9]\n\nprint(liste[4])\nprint(liste[3:5])\nprint(liste[:7])\nprint(liste[-3])\nprint(len(liste))\n\n16\n[8, 16]\n[2, 17, 3, 8, 16, 32, -5]\n5\n11\n\n\n\n\n2. Aufgabe\n\nwoerter = [\"Haus\", \"Baum\", \"Informatik\", \"Schule\", \"Programmierung\", \"PC\", \"Python\"]\n\nfor wort in woerter:\n    if len(wort) &gt; 5:\n        print(wort)\n\nInformatik\nSchule\nProgrammierung\nPython\n\n\n\n\n3. Aufgabe\n\nliste = [2, 17, 3, 8, 16, 32, -5, 20, 5, 10, 9]\n\n# Größte Zahl finden\ngroesste_zahl = liste[0]\n\nfor zahl in liste:\n    if zahl &gt; groesste_zahl:\n        groesste_zahl = zahl\n\n# Kleinste Zahl finden\nkleinste_zahl = liste[0]\n\nfor zahl in liste:\n    if zahl &lt; kleinste_zahl:\n        kleinste_zahl = zahl\n\nprint(f\"Die größte Zahl ist {groesste_zahl}\")\nprint(f\"Die kleinste Zahl ist {kleinste_zahl}\")\n\nDie größte Zahl ist 32\nDie kleinste Zahl ist -5"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html",
    "href": "pk-programmieren/02-flow-control.html",
    "title": "Flow control",
    "section": "",
    "text": "In Programmen hat man oft “wenn … dann …” Situationen. Im “wenn”-Teil steht eine Bedingung, die entweder wahr (True) oder falsch (False) ist. Diese Bedingungen werden in Python mit boolschen Ausdrücken dargestellt.\nHäufig ergeben sich boolsche Ausdrücke mit Vergleichsoperatoren.\nprint(f\"5 == 5 ist {5 == 5}\") \nprint(f\"5 == 3 ist {5 == 3}\") \n\nprint(f\"5 != 3 ist {5 != 3}\") \nprint(f\"5 != 5 ist {5 != 5}\")\n\nprint(f\"3 &lt; 5 ist {3 &lt; 5}\")\nprint(f\"5 &lt; 5 ist {5 &lt; 5}\")\n\n5 == 5 ist True\n5 == 3 ist False\n5 != 3 ist True\n5 != 5 ist False\n3 &lt; 5 ist True\n5 &lt; 5 ist False\nVergleiche funktionieren auch mit Variablen:\na = 10\nb = 20\nprint(f\"Für a = {a} und b = {b} ist a &lt; b {a &lt; b}.\")\n\nFür a = 10 und b = 20 ist a &lt; b True.\nMan kann boolsche Werte in Variablen abspeichern:\nvergleich1 = 5 &gt; 3\nvergleich2 = 3 &lt; 1\nprint(f\"vergleich1 ist {vergleich1}, vergleich2 ist {vergleich2}\")\n\nvergleich1 ist True, vergleich2 ist False\nBoolsche Ausdrücke können mit logischen Operatoren kombiniert werden.\nprint(f\"(5 &gt; 3) and (3 &lt; 1): {(5 &gt; 3) and (3 &lt; 1)}\")  \nprint(f\"(5 &gt; 3) and (3 &gt; 1): {(5 &gt; 3) and (3 &gt; 1)}\")  \nprint(f\"(5 &gt; 3) or (3 &lt; 1): {(5 &gt; 3) or (3 &lt; 1)}\")  \nprint(f\"(5 &lt; 3) or (3 &lt; 1): {(5 &lt; 3) or (3 &lt; 1)}\")  \nprint(f\"not (5 &gt; 3): {not (5 &gt; 3)}\")  \nprint(f\"not (5 &lt; 3): {not (5 &lt; 3)}\")  \n\n(5 &gt; 3) and (3 &lt; 1): False\n(5 &gt; 3) and (3 &gt; 1): True\n(5 &gt; 3) or (3 &lt; 1): True\n(5 &lt; 3) or (3 &lt; 1): False\nnot (5 &gt; 3): False\nnot (5 &lt; 3): True\nBesonderheiten: int- und float-Typen können untereinander verglichen werden, String-Ausdrücke können nicht mit Zahlentypen verglichen werden. Jedoch können Strings untereinander verglichen werden.\nprint(f\"5 == 5.0: {5 == 5.0}\")\nprint(f\"5 == '5': {5 == '5'}\")\nprint(f\"'Hallo' == 'Hallo': {'Hallo' == 'Hallo'}\")\n\n5 == 5.0: True\n5 == '5': False\n'Hallo' == 'Hallo': True"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#if-anweisung",
    "href": "pk-programmieren/02-flow-control.html#if-anweisung",
    "title": "Flow control",
    "section": "if-Anweisung",
    "text": "if-Anweisung\nDie if-Anweisung wird verwendet, um Code nur dann auszuführen, wenn eine bestimmte Bedingung erfüllt ist. Ist die Bedingung wahr (True), wird der eingerückte Codeblock ausgeführt. Ist sie falsch (False), wird der Codeblock übersprungen.\nDie Syntax lautet:\nif [boolscher Ausdruck]:\n    ...\n    ...\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nIn diesem Beispiel wird die Ausgabe nur angezeigt, wenn a tatsächlich kleiner als b ist.\n\na = 5\nb = 10\nif a &lt; b:\n    print(\"a ist kleiner als b\")\n\nif b == a:\n    print(\"b ist gleich a\")\n\na ist kleiner als b\n\n\nDie else-Anweisung wird verwendet, um einen Codeblock auszuführen, wenn die Bedingung der vorherigen if-Anweisung nicht erfüllt ist. Sie ergänzt die if-Anweisung und sorgt dafür, dass genau einer der beiden Blöcke ausgeführt wird.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\nIn diesem Beispiel wird die Ausgabe im else-Block nur angezeigt, wenn die Bedingung a &lt; b falsch ist.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\n\na ist nicht kleiner als b\n\n\nDie elif-Anweisung steht für “else if” und wird verwendet, um mehrere Bedingungen in einer if-else-Struktur zu überprüfen. Sie folgt auf eine if-Anweisung und vor einer optionalen else-Anweisung. Sobald eine Bedingung wahr ist, wird der zugehörige Codeblock ausgeführt und die restlichen Bedingungen werden übersprungen.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\nMit elif können also mehrere Alternativen übersichtlich hintereinander geprüft werden.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\n\na ist größer als b\n\n\nAchtung: Sobald eine elif-Bedingung richtig ist, wird der Rest nicht mehr geprüft:\n\na = 1000\nb = 5\nif a &gt; b:\n    print(\"a ist größer als b\")\nelif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist größer als b\n\n\nÄndert man die Reihenfolge, funktioniert es:\n\na = 1000\nb = 5\nif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelif a &gt; b:\n    print(\"a ist größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist viel größer als b"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#while-schleifen",
    "href": "pk-programmieren/02-flow-control.html#while-schleifen",
    "title": "Flow control",
    "section": "While-Schleifen",
    "text": "While-Schleifen\nDie while-Schleife wird verwendet, um einen Codeblock so lange zu wiederholen, wie eine bestimmte Bedingung wahr (True) ist. Die Bedingung wird vor jedem Durchlauf überprüft. Sobald sie falsch (False) wird, endet die Schleife. Die Syntax ist:\nwhile [boolscher Ausdruck]:\n    ...\n    ...\n\neingabe = int(input(\"Was ist 5 + 3? \")) # Eingabe: 7\nwhile eingabe != 8:\n    print(\"Falsch! Versuch es noch einmal.\")\n    eingabe = int(input(\"Was ist 5 + 3? \")) # Einfabe: 8\nprint(\"Richtig!\")\n\n\n\nWas ist 5 + 3? 7\nFalsch! Versuch es noch einmal.\nWas ist 5 + 3? 8\nRichtig!\n\n\nWir suchen durch Ausprobieren die kleinste Zahl, die durch 18 und 12 teilbar ist:\n\nzahl = 1\nwhile (zahl % 18 != 0) or (zahl % 12 != 0):\n    zahl = zahl + 1\nprint(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie break-Anweisung wird verwendet, um eine Schleife vorzeitig zu beenden. Sobald break im Schleifen-Block ausgeführt wird, wird die Schleife sofort verlassen und das Programm läuft mit dem Code nach der Schleife weiter.\nTypischerweise wird break eingesetzt, wenn eine bestimmte Bedingung innerhalb der Schleife erfüllt ist und keine weiteren Durchläufe mehr nötig sind.\nBeispiel von oben in abgeänderter Form:\n\nzahl = 1\nwhile True:\n    if (zahl % 18 == 0) and (zahl % 12 == 0):\n        print(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n        break\n    zahl = zahl + 1\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie continue-Anweisung springt wieder zum Beginn der Schleife, der Rest der Anweisung wird für diesen Durchgang ausgelassen.\n\nwhile True:\n    name = input(\"Wer bist du? \") # Eingabe: Master, danach: Doctor\n    if name != \"Doctor\":\n        continue\n    print(\"Hallo Doctor! Was ist das Passwort?\")\n    passwort = input(\"Passwort: \") # Eingabe: Tardis\n    if passwort == \"Tardis\":\n        break\nprint(\"Zutritt gewährt.\")\n\n\n\nWer bist du? Master\nWer bist du? Doctor\nHallo Doctor! Was ist das Passwort? Tardis\nZutritt gewährt."
  },
  {
    "objectID": "pk-programmieren/pk-prog.html",
    "href": "pk-programmieren/pk-prog.html",
    "title": "P-Kurs Programmieren",
    "section": "",
    "text": "Einführung in Python\nSkript\n\n\nLösungen zu den Aufgaben\n\nÜbungen/Kontrollfragen zu 01 - Grundlagen\nÜbungen/Kontrollfragen zu 02 - Flow control\nÜbungen/Kontrollfragen zu 04 - Listen"
  },
  {
    "objectID": "pk-programmieren/04-Listen.html",
    "href": "pk-programmieren/04-Listen.html",
    "title": "Listen",
    "section": "",
    "text": "Listen sind eine Datenstruktur, die “unter dem Dach” einer Variable mehrere Daten speichern kann. Eine Liste wird in Python mit eckigen Klammern [] definiert. Beispiel:\nmeine_liste = [3, 5, 7, 9]\nprint(meine_liste)\n\n[3, 5, 7, 9]\nDie einzelnen Elemente einer Liste werden items genannt. Die Items in einer Liste können unterschiedliche Datentypen haben:\ngemischte_liste = [42, \"Hallo\", 3.14, True]\nprint(gemischte_liste)\n\n[42, 'Hallo', 3.14, True]\nEine Liste kann auch leer sein:\nleere_liste = []\nprint(leere_liste)\n\n[]"
  },
  {
    "objectID": "pk-programmieren/04-Listen.html#zugriff-auf-listenelemente",
    "href": "pk-programmieren/04-Listen.html#zugriff-auf-listenelemente",
    "title": "Listen",
    "section": "Zugriff auf Listenelemente",
    "text": "Zugriff auf Listenelemente\nDie Elemente einer Liste sind durchnummeriert, beginnend bei 0. In der Liste gemischte_liste = [42, \"Hallo\", 3.14, True] aus dem obigen Beispiel hat also die folgenden Indizes:\n\nIndex 0: 42\nIndex 1: “Hallo”\nIndex 2: 3.14\nIndex 3: True\n\nMan kann auf die einzelnen Elemente einer Liste über ihren Index zugreifen, indem man den Listennamen gefolgt von eckigen Klammern mit dem Index schreibt:\n\nprint(gemischte_liste[1])  \n\nHallo\n\n\nMit [Anfangsindex:Endindex] innerhalb der eckigen Klammern kann man auch einen Ausschnitt (Slice) der Liste erhalten, d.h. alle Elemente von Anfangsindex (einschließlich) bis Endindex (ausschließlich).\ngemischte_liste[1:3] liefert die Elemente mit den Indizes 1 und 2, aber nicht das Element mit dem Endindex 3:\n\nprint(gemischte_liste[1:3]) \n\n['Hallo', 3.14]\n\n\nMan kann den Anfangs- oder Endindex auch weglassen. Wird der Anfangsindex weggelassen, so wird automatisch 0 verwendet. Wird der Endindex weggelassen, so wird automatisch das Ende der Liste verwendet:\n\nprint(gemischte_liste[:3])  \nprint(gemischte_liste[1:])   \n\n[42, 'Hallo', 3.14]\n['Hallo', 3.14, True]\n\n\nVerwendet man einen negativen Index, so wird von hinten gezählt, wobei -1 das letzte Element ist:\n\nprint(gemischte_liste[-1])\nprint(gemischte_liste[-3:])\n\nTrue\n['Hallo', 3.14, True]\n\n\nDie Länge einer Liste kann mit der Funktion len(...) (analog zur Länge eines Strings) ermittelt werden:\n\nprint(len(gemischte_liste))\n\n4"
  },
  {
    "objectID": "pk-programmieren/04-Listen.html#listen-und-schleifen",
    "href": "pk-programmieren/04-Listen.html#listen-und-schleifen",
    "title": "Listen",
    "section": "Listen und Schleifen",
    "text": "Listen und Schleifen\nListen werden oft in Verbindung mit Schleifen verwendet, um alle Elemente der Liste zu durchlaufen.Dafür wird die sogenannte for-Schleife verwendet. Der Syntax ist:\nfor variable in liste:\n    # mache etwas mit variable\nDabei wird die variable nacheinander auf jedes Element der liste gesetzt, und der eingerückte Codeblock wird für jedes Element ausgeführt, bis die ganze Liste abgearbeitet ist.\nBeispiel:\n\nfor item in gemischte_liste:\n    print(item)\n\n42\nHallo\n3.14\nTrue"
  }
]