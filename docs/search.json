[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fabian Bühler",
    "section": "",
    "text": "Hier finden sich Materialien zu meinem Unterricht im Schuljahr 2025/26 am Störck-Gymnasium in Bad Saulgau.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "pk-prog.html",
    "href": "pk-prog.html",
    "title": "P-Kurs Programmieren",
    "section": "",
    "text": "1. Grundlagen\n2. Flow control",
    "crumbs": [
      "P-Kurs Programmieren"
    ]
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html",
    "href": "pk-programmieren/02-flow-control.html",
    "title": "Flow control",
    "section": "",
    "text": "In Programmen hat man oft “wenn … dann …” Situationen. Im “wenn”-Teil steht eine Bedingung, die entweder wahr (True) oder falsch (False) ist. Diese Bedingungen werden in Python mit boolschen Ausdrücken dargestellt.\nHäufig ergeben sich boolsche Ausdrücke mit Vergleichsoperatoren.\nprint(f\"5 == 5 ist {5 == 5}\") \nprint(f\"5 == 3 ist {5 == 3}\") \n\nprint(f\"5 != 3 ist {5 != 3}\") \nprint(f\"5 != 5 ist {5 != 5}\")\n\nprint(f\"3 &lt; 5 ist {3 &lt; 5}\")\nprint(f\"5 &lt; 5 ist {5 &lt; 5}\")\n\n5 == 5 ist True\n5 == 3 ist False\n5 != 3 ist True\n5 != 5 ist False\n3 &lt; 5 ist True\n5 &lt; 5 ist False\nVergleiche funktionieren auch mit Variablen:\na = 10\nb = 20\nprint(f\"Für a = {a} und b = {b} ist a &lt; b {a &lt; b}.\")\n\nFür a = 10 und b = 20 ist a &lt; b True.\nMan kann boolsche Werte in Variablen abspeichern:\nvergleich1 = 5 &gt; 3\nvergleich2 = 3 &lt; 1\nprint(f\"vergleich1 ist {vergleich1}, vergleich2 ist {vergleich2}\")\n\nvergleich1 ist True, vergleich2 ist False\nBoolsche Ausdrücke können mit logischen Operatoren kombiniert werden.\nprint(f\"(5 &gt; 3) and (3 &lt; 1): {(5 &gt; 3) and (3 &lt; 1)}\")  \nprint(f\"(5 &gt; 3) and (3 &gt; 1): {(5 &gt; 3) and (3 &gt; 1)}\")  \nprint(f\"(5 &gt; 3) or (3 &lt; 1): {(5 &gt; 3) or (3 &lt; 1)}\")  \nprint(f\"(5 &lt; 3) or (3 &lt; 1): {(5 &lt; 3) or (3 &lt; 1)}\")  \nprint(f\"not (5 &gt; 3): {not (5 &gt; 3)}\")  \nprint(f\"not (5 &lt; 3): {not (5 &lt; 3)}\")  \n\n(5 &gt; 3) and (3 &lt; 1): False\n(5 &gt; 3) and (3 &gt; 1): True\n(5 &gt; 3) or (3 &lt; 1): True\n(5 &lt; 3) or (3 &lt; 1): False\nnot (5 &gt; 3): False\nnot (5 &lt; 3): True\nBesonderheiten: int- und float-Typen können untereinander verglichen werden, String-Ausdrücke können nicht mit Zahlentypen verglichen werden. Jedoch können Strings untereinander verglichen werden.\nprint(f\"5 == 5.0: {5 == 5.0}\")\nprint(f\"5 == '5': {5 == '5'}\")\nprint(f\"'Hallo' == 'Hallo': {'Hallo' == 'Hallo'}\")\n\n5 == 5.0: True\n5 == '5': False\n'Hallo' == 'Hallo': True"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#if-anweisung",
    "href": "pk-programmieren/02-flow-control.html#if-anweisung",
    "title": "Flow control",
    "section": "if-Anweisung",
    "text": "if-Anweisung\nDie if-Anweisung wird verwendet, um Code nur dann auszuführen, wenn eine bestimmte Bedingung erfüllt ist. Ist die Bedingung wahr (True), wird der eingerückte Codeblock ausgeführt. Ist sie falsch (False), wird der Codeblock übersprungen.\nDie Syntax lautet:\nif [boolscher Ausdruck]:\n    ...\n    ...\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nIn diesem Beispiel wird die Ausgabe nur angezeigt, wenn a tatsächlich kleiner als b ist.\n\na = 5\nb = 10\nif a &lt; b:\n    print(\"a ist kleiner als b\")\n\nif b == a:\n    print(\"b ist gleich a\")\n\na ist kleiner als b\n\n\nDie else-Anweisung wird verwendet, um einen Codeblock auszuführen, wenn die Bedingung der vorherigen if-Anweisung nicht erfüllt ist. Sie ergänzt die if-Anweisung und sorgt dafür, dass genau einer der beiden Blöcke ausgeführt wird.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\nIn diesem Beispiel wird die Ausgabe im else-Block nur angezeigt, wenn die Bedingung a &lt; b falsch ist.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\n\na ist nicht kleiner als b\n\n\nDie elif-Anweisung steht für “else if” und wird verwendet, um mehrere Bedingungen in einer if-else-Struktur zu überprüfen. Sie folgt auf eine if-Anweisung und vor einer optionalen else-Anweisung. Sobald eine Bedingung wahr ist, wird der zugehörige Codeblock ausgeführt und die restlichen Bedingungen werden übersprungen.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\nMit elif können also mehrere Alternativen übersichtlich hintereinander geprüft werden.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\n\na ist größer als b\n\n\nAchtung: Sobald eine elif-Bedingung richtig ist, wird der Rest nicht mehr geprüft:\n\na = 1000\nb = 5\nif a &gt; b:\n    print(\"a ist größer als b\")\nelif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist größer als b\n\n\nÄndert man die Reihenfolge, funktioniert es:\n\na = 1000\nb = 5\nif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelif a &gt; b:\n    print(\"a ist größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist viel größer als b"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#while-schleifen",
    "href": "pk-programmieren/02-flow-control.html#while-schleifen",
    "title": "Flow control",
    "section": "While-Schleifen",
    "text": "While-Schleifen\nDie while-Schleife wird verwendet, um einen Codeblock so lange zu wiederholen, wie eine bestimmte Bedingung wahr (True) ist. Die Bedingung wird vor jedem Durchlauf überprüft. Sobald sie falsch (False) wird, endet die Schleife. Die Syntax ist:\nwhile [boolscher Ausdruck]:\n    ...\n    ...\n\neingabe = int(input(\"Was ist 5 + 3? \")) # Eingabe: 7\nwhile eingabe != 8:\n    print(\"Falsch! Versuch es noch einmal.\")\n    eingabe = int(input(\"Was ist 5 + 3? \")) # Einfabe: 8\nprint(\"Richtig!\")\n\n\n\nWas ist 5 + 3? 7\nFalsch! Versuch es noch einmal.\nWas ist 5 + 3? 8\nRichtig!\n\n\nWir suchen durch Ausprobieren die kleinste Zahl, die durch 18 und 12 teilbar ist:\n\nzahl = 1\nwhile (zahl % 18 != 0) or (zahl % 12 != 0):\n    zahl = zahl + 1\nprint(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie break-Anweisung wird verwendet, um eine Schleife vorzeitig zu beenden. Sobald break im Schleifen-Block ausgeführt wird, wird die Schleife sofort verlassen und das Programm läuft mit dem Code nach der Schleife weiter.\nTypischerweise wird break eingesetzt, wenn eine bestimmte Bedingung innerhalb der Schleife erfüllt ist und keine weiteren Durchläufe mehr nötig sind.\nBeispiel von oben in abgeänderter Form:\n\nzahl = 1\nwhile True:\n    if (zahl % 18 == 0) and (zahl % 12 == 0):\n        print(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n        break\n    zahl = zahl + 1\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie continue-Anweisung springt wieder zum Beginn der Schleife, der Rest der Anweisung wird für diesen Durchgang ausgelassen.\n\nwhile True:\n    name = input(\"Wer bist du? \") # Eingabe: Master, danach: Doctor\n    if name != \"Doctor\":\n        continue\n    print(\"Hallo Doctor! Was ist das Passwort?\")\n    passwort = input(\"Passwort: \") # Eingabe: Tardis\n    if passwort == \"Tardis\":\n        break\nprint(\"Zutritt gewährt.\")\n\n\n\nWer bist du? Master\nWer bist du? Doctor\nHallo Doctor! Was ist das Passwort? Tardis\nZutritt gewährt."
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html",
    "href": "pk-programmieren/03-Funktionen.html",
    "title": "Funktionen",
    "section": "",
    "text": "print(...) oder input(...) oder len(...) sind Beispiele für (bereits vorhandene) Funktionen in Python. Man benutzt Funktionen immer auf die gleiche Weise: Man schreibt den Funktionsnamen und in runden Klammern die sog. Argumente, die der Funktion mitgegeben werden.\nWas bedeutet die Formulierung “liefert … zurück” genau? Liefert eine Funktion ein Ergebnis zurück, so wird im Python-Ausdruck an der Stelle, an der die Funktion aufgerufen wird, das zurückgelieferte Ergebnis eingesetzt. Beispiel:\nDie Funktion len(\"Hallo\")+3 liefert den Wert 5 zurück. Damit wird aus dem Ausdruck len(\"Hallo\")+3 wird 5+3 und schließlich 8.\nDie Anzahl der übergebenen Argumente (auch Parameter genannt) ist unterschiedlich: es gibt Funktionen ohne Argument, mit einem Argument oder mit mehreren Argumenten. Beim Aufruf einer Funktion ohne Argument müssen trotzdem runde Klammern geschrieben werden, z.B.:"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "href": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "title": "Funktionen",
    "section": "Definition einer Funktion",
    "text": "Definition einer Funktion\nMan kann in Python eigene Funktionen definieren. Beispiel:\n\ndef schreibeHallo():\n    print(\"Hallo!\")\n    print(\"Heute ist ein schöner Tag, oder nicht?\")\n\nBei der Definition wird ein eingerückter Codeblock verwendet, analog zu den Codeblöcken, die in der Ablaufsteuerung bei if oder while verwendet werden.\nNun kann die so definierte Funktion schreibeHallo() wie alle anderen Python-Funktionen benutzt werden:\n\nprint(\"irgendein anderer Text\")\nschreibeHallo()\nprint(\"noch mehr Text\")\n\nirgendein anderer Text\nHallo!\nHeute ist ein schöner Tag, oder nicht?\nnoch mehr Text\n\n\nDie Funktion schreibeHallo() wurde ohne Argumente definiert. In diesem Fall darf man auch keines verwenden.\n\nschreibeHallo(\"Peter\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 schreibeHallo(\"Peter\")\n\nTypeError: schreibeHallo() takes 0 positional arguments but 1 was given"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "href": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "title": "Funktionen",
    "section": "Funktionsdefinition mit Argumenten",
    "text": "Funktionsdefinition mit Argumenten\nArgumente kann man bei der Definition der Funktion in den runden Klammern angeben. Dabei darf man beliebige Variablennamen verwenden.\n\ndef schreibeHallo(name):\n    print(f\"Hallo, {name}!\")\n    laenge = len(name)\n    print(f\"Dein Name ist {laenge} Buchstaben lang.\")\n\nJetzt hat schreibeHallo einen Parameter. Der muss beim Aufruf auch angegeben werden.\n\nschreibeHallo(\"Egon\")\nschreibeHallo(\"Walburga\")\nschreibeHallo()\n\nHallo, Egon!\nDein Name ist 4 Buchstaben lang.\nHallo, Walburga!\nDein Name ist 8 Buchstaben lang.\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 3\n      1 schreibeHallo(\"Egon\")\n      2 schreibeHallo(\"Walburga\")\n----&gt; 3 schreibeHallo()\n\nTypeError: schreibeHallo() missing 1 required positional argument: 'name'\n\n\n\nDie Bezeichnung name für das Argument ist eine interne Bezeichnung, die nur in der Funktionsdefinition Bedeutung hat. Außerhalb der Definition spielt diese Bezeichnung keine Rolle.\n\nmeinVorname = \"Ignatius\"\nschreibeHallo(meinVorname)\n\nHallo, Ignatius!\nDein Name ist 8 Buchstaben lang.\n\n\nMan kann auch Funktionen mit mehreren Argumenten definieren:\n\ndef schreibeHallo(name, alter):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)\nschreibeHallo(\"Anna\", 30)\nschreibeHallo(\"Opa\", 70)\n\nHi Max!\nHallo, Anna!\nGuten Tag, Opa!"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "href": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "title": "Funktionen",
    "section": "Rückgabewerte",
    "text": "Rückgabewerte\nSelbst definierte Funktionen können ebenso wie z.B. len(...) Rückgabewerte haben. Dazu verwendet man in der Funktionsdefinition die Anweisung return. Dahinter wird der Rückgabewert angegeben.\n\ndef rechteckFlaeche(breite, hoehe):\n    flaeche = breite * hoehe\n    return flaeche\n\nDie Verwendung funktioniert wie bei anderen Funktionen mit Rückgabewert auch:\n\nb = 5\nh = 10\nA = rechteckFlaeche(b, h)\nprint(f\"Die Fläche des Rechtecks mit Breite {b} und Höhe {h} ist {A}.\")\n\nDie Fläche des Rechtecks mit Breite 5 und Höhe 10 ist 50.\n\n\nMan kann in der Definition mehrere return-Anweisungen verwenden. Die Ausführung der Funktion endet mit der ersten return-Anweisung, die ausgeführt wird.\n\ndef rechteckFlaeche(breite, hoehe):\n    if breite &lt; 0 or hoehe &lt; 0:\n        return \"Ungültige Eingabe: Breite und Höhe müssen positiv sein.\"\n    flaeche = breite * hoehe\n    return flaeche\n\n\nprint(rechteckFlaeche(5, 10))\nprint(rechteckFlaeche(-5, 10))\n\n50\nUngültige Eingabe: Breite und Höhe müssen positiv sein."
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "href": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "title": "Funktionen",
    "section": "keyword-Argumente",
    "text": "keyword-Argumente\nIm Normalfall werden die Argumente einer Funktion in der Reihenfolge übergeben, wie sie in der Funktionsdefinition angegeben. In der Funktionsdefinition im Beispiel oben\ndef schreibeHallo(name, alter):\nist der erste Parameter name, der zweite alter. Die Reihenfolge, in der die Argumente beim Aufruf angegeben werden, muss dieser Reihenfolge entsprechen.\nDavon unterscheiden sich die sogenannten keyword-Argumente. Dabei bekommen die einzelnen Argumente Namen, die beim Aufruf der Funktion mit angegeben werden mussen. Dadurch kann die Reihenfolge der Argumente beim Aufruf geändert werden.\nDie obige Beispielfunktion schreibeHallo kann auch so aufgerufen werden:\n\nschreibeHallo(alter=14, name=\"Max\")\n\nHi Max!\n\n\nHier werden die Argumente name und alter explizit benannt. Dadurch ist die Reihenfolge der Argumente beim Aufruf egal.\nMan darf keyword-Argumente und normale Argumente auch mischen. Dabei müssen die normalen Argumente zuerst angegeben werden, danach die keyword-Argumente.\n\nschreibeHallo(\"Max\", alter=14)\n\nHi Max!\n\n\nVerwendet man nach einem keyword-Argument ein nicht-keyword-Argument, so führt das zu einem Fehler:\n\nschreibeHallo(name=\"Max\", 14)\n\n\n  Cell In[15], line 1\n    schreibeHallo(name=\"Max\", 14)\n                                ^\nSyntaxError: positional argument follows keyword argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "href": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "title": "Funktionen",
    "section": "optionale Argumente und default-Werte",
    "text": "optionale Argumente und default-Werte\nEs ist möglich, in der Funktionsdefinition für Argumente default-Werte anzugeben. Diese Werte werden verwendet, wenn beim Aufruf der Funktion kein entsprechendes Argument angegeben wird.\n\ndef schreibeHallo(name, alter=30):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)   # alter wird mit 14 belegt\nschreibeHallo(\"Anna\")      # alter wird mit default-Wert 30 belegt\n\nHi Max!\nHallo, Anna!\n\n\nMan kann auch mehr als ein Argument mit einem default-Wert versehen.\ndef schreibeHallo(name=\"John\", alter=30):\n    ...\n\nschreibeHallo(\"Max\")\nschreibeHallo()\n\nHallo, Max!\nHallo, John!\n\n\nGibt es Argumente ohne default-Wert, müssen diese bei der Definition vor den Argumenten mit default-Wert angegeben werden. Folgendes führt zu einem Fehler:\ndef schreibeHallo(name=\"John\", alter):\n    ...\n\n\n\n  Cell In[20], line 1\n    def schreibeHallo(name=\"John\", alter):\n                                   ^\nSyntaxError: non-default argument follows default argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "href": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "title": "Funktionen",
    "section": "lokaler und globaler Scope",
    "text": "lokaler und globaler Scope"
  },
  {
    "objectID": "pk-programmieren/01-grundlagen.html",
    "href": "pk-programmieren/01-grundlagen.html",
    "title": "Grundlagen",
    "section": "",
    "text": "Operator\nBedeutung\n\n\n\n\n+\nAddition\n\n\n-\nSubtraktion\n\n\n*\nMultiplikation\n\n\n/\nDivision\n\n\n//\nganzzahlige Division\n\n\n%\nModulo (Rest der Division)\n\n\n**\nPotenzierung\n\n\n\n\nprint(3 + 2)  \nprint(3 - 2)  \nprint(3 * 2)  \nprint(3 / 2)  \nprint(3 // 2)  \nprint(3 % 2)  \nprint(3**2)  \n\n5\n1\n6\n1.5\n1\n1\n9\n\n\nErzeugung von Leerzeilen: Die Zeichenkette \\n in einem String erzeugt eine neue Zeile.\n\nprint(\"Text\\nText\")\nprint(\"\\n\")\nprint(\"Text\")\n\nText\nText\n\n\nText\n\n\nReihenfolge der Operatoren: - Klammern haben Vorrang - Multiplikation vor Addition - Potenzierung vor Multiplikation vor Addition\n\nprint(3 + 2 * 5)  # Multiplikation vor Addition\nprint((3 + 2) * 5)  # Klammern haben Vorrang\nprint(3 + 2 * 5**2)  # Potenzierung vor Multiplikation vor Addition\n\n13\n25\n53\n\n\n\nDatentypen\n\n\n\nTypname\nArt der Daten\n\n\n\n\ninteger\nganze Zahlen\n\n\nfloat\nGleitkommazahlen\n\n\nString\nZeichenketten\n\n\nBoolean\nWahrheitswert (True oder False)\n\n\nNoneType\nWert None\n\n\n\n\nprint(type(42))  # Integer (Ganzzahl)\nprint(type(3.14))  # Float (Gleitkommazahl)\nprint(type(\"Hallo\"))  # String (Text)\nprint(type(True), type(False))  # Boolean (Wahrheitswert)\nprint(type(None))  # NoneType (kein Wert)\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt; &lt;class 'bool'&gt;\n&lt;class 'NoneType'&gt;\n\n\n\n\nUmgang mit Strings\n\n\n\nOperation\nCode\n\n\n\n\nKonkatenation (Verkettung)\n\"Alice\" + \"Bob\"\n\n\nWiederholung\n\"Alice\" * 3\n\n\nNeue Zeile\n\"\\n\"\n\n\nUmwandeln in Großbuchstaben\n\"...\".upper()\n\n\nUmwandeln in Kleinbuchstaben\n\"...\".lower()\n\n\nLeerzeichen entfernen am Rand\n\"...\".strip()\n\n\n\n\nprint(\"Alice\" + \"Bob\") \nprint(\"Alice \" * 3)  \nprint(\"Hallo\\nWelt\") \nprint(\"mach mich groß\".upper())\nprint(\"MACH MICH KLEIN\".lower())\nprint(\"  zuschneiden bitte  \".strip())\n\nAliceBob\nAlice Alice Alice \nHallo\nWelt\nMACH MICH GROSS\nmach mich klein\nzuschneiden bitte\n\n\nMit f-Strings kann man Python-Ausdrücke in Strings einbetten. Alle Teile, die zwischen {...} eingeschlossen sind, werden als Python-Ausdrücke ausgewertet und das Ergebnis der Auswertung an dieser Stelle in den String eingefügt.\n\nprint(f\"2 + 2 = {2 + 2}\")\n\n2 + 2 = 4\n\n\nMit len(...) kann man die Länge eines Strings ermitteln.\n\ns = \"Guten Morgen!\"\nprint(len(s))\n\n13\n\n\n\n\nVariablen verwenden\nEine Variable ist wie eine “Schachtel” im Computerspeicher, wo man Daten ablegen kann. Weißt man einem Variablennamen mit = erstmals einen Wert zu, wird die entsprechende Variable im Computerspeicher angelegt.\nEine Variable mit Namen alter wird angelegt und mit dem Wert 15 belegt:\n\nalter = 15\n\nVerwendet man im Folgenden den Namen alter, wird auf den gespeicherten Wert zugegriffen:\n\nprint(alter)\nprint(alter + 5)\n\n15\n20\n\n\nVariablen haben einen Typ, der ihrem Inhalt entspricht:\n\nprint(type(alter))\n\n&lt;class 'int'&gt;\n\n\nDer Variablentyp kann sich ändern, wenn die Variable mit einem neuen Wert belegt wird:\n\nalter = 2.5\nprint(type(alter))\n\nalter = \"fünfzehn\"\nprint(type(alter))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nFür Variablennamen gelten folgende Regeln: - Dürfen nur Buchstaben, Zahlen und Unterstriche (_) enthalten - Dürfen nicht mit einer Zahl beginnen - Dürfen nur aus einem Wort bestehen (keine Leerzeichen)\nerlaubt z.B.: mein_name, alter2, _preis\nnicht erlaubt z.B.: 2alter, mein name, mein-name\n\n\nInput-Befehl\nDer Befehl input(\"...\") gibt den angegebenen String aus und wartet anschließend auf eine Eingabe des Benutzers. Die Eingabe wird als String-Wert dem Programm zurückgegeben und kann z.B. in einer Variable abgelegt werden.\nHier wird die Eingabe des Benutzers in der Variable name abgelegt:\nname = input(\"Wie heißt du?\")\n\nname = input(\"Wie heißt du? \") # Eingabe: Dornröschen\nprint(\"Hallo \" + name + \"!\")\n\n\n\nHallo Dornröschen!\n\n\nAchtung: input() gibt immer einen String zurück.\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nprint(type(eingabe))\n\n\n\n&lt;class 'str'&gt;\n\n\nDer eine Zahl enthaltende String kann aber in einen Zahltyp (int oder float) umgewandelt werden mit int(...) oder float(...).\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nzahl = int(eingabe)\nprint(type(zahl))\nprint(zahl + 5) \n\n\n\n&lt;class 'int'&gt;\n47\n\n\nAnalog kann man auch in float oder String umwandeln:\n\nvar = float(\"42.5\")\nprint(type(var))\nzahl = 17\nprint(type(str(zahl)))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\n\nFormatierte Ausgabe mit f-Strings\nBei der Ausgabe mit f-Strings kann man Formatierungsvorgaben machen.\n\nname1 = \"Alice\"\nname2 = \"Bob\"\nname3 = \"Charlie\"\nalter1 = 15\nalter2 = 16\nalter3 = 18\ngroesse1 = 1.70\ngroesse2 = 1.85\ngroesse3 = 1.7382\n\nprint(\"Name     Alter   Größe\")\nprint(f\"{name1:8} {alter1:5d} {groesse1:7.2f}\")\nprint(f\"{name2:8} {alter2:5d} {groesse2:7.2f}\")\nprint(f\"{name3:8} {alter3:5d} {groesse3:7.2f}\")\n\nName     Alter   Größe\nAlice       15    1.70\nBob         16    1.85\nCharlie     18    1.74\n\n\nMöglichkeiten der Formatierung:\n\n\n\n\n\n\n\nFormat\nBedeutung\n\n\n\n\n:8\nmindestens 8 Zeichen breit, rechtsbündig (Standard)\n\n\n:5d\nmindestens 5 Zeichen breit, rechtsbündig, Integer (d = decimal)\n\n\n:7.2f\nmindestens 7 Zeichen breit, rechtsbündig, Fließkommazahl (f = float) mit 2 Nachkommastellen\n\n\n\nEs gibt viele weitere Formatierungsmöglichkeiten. Eine vollständige Übersicht findet man in der Python-Dokumentation:https://docs.python.org/3/library/string.html#formatspec"
  }
]