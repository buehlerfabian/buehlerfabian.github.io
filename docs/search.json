[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fabian Bühler",
    "section": "",
    "text": "Hier finden sich Materialien zu meinem Unterricht im Schuljahr 2025/26 am Störck-Gymnasium in Bad Saulgau."
  },
  {
    "objectID": "pk-programmieren/01-grundlagen.html",
    "href": "pk-programmieren/01-grundlagen.html",
    "title": "Grundlagen",
    "section": "",
    "text": "Operator\nBedeutung\n\n\n\n\n+\nAddition\n\n\n-\nSubtraktion\n\n\n*\nMultiplikation\n\n\n/\nDivision\n\n\n//\nganzzahlige Division\n\n\n%\nModulo (Rest der Division)\n\n\n**\nPotenzierung\n\n\n\n\nprint(3 + 2)  \nprint(3 - 2)  \nprint(3 * 2)  \nprint(3 / 2)  \nprint(3 // 2)  \nprint(3 % 2)  \nprint(3**2)  \n\n5\n1\n6\n1.5\n1\n1\n9\n\n\nErzeugung von Leerzeilen: Die Zeichenkette \\n in einem String erzeugt eine neue Zeile.\n\nprint(\"Text\\nText\")\nprint(\"\\n\")\nprint(\"Text\")\n\nText\nText\n\n\nText\n\n\nReihenfolge der Operatoren: - Klammern haben Vorrang - Multiplikation vor Addition - Potenzierung vor Multiplikation vor Addition\n\nprint(3 + 2 * 5)  # Multiplikation vor Addition\nprint((3 + 2) * 5)  # Klammern haben Vorrang\nprint(3 + 2 * 5**2)  # Potenzierung vor Multiplikation vor Addition\n\n13\n25\n53\n\n\n\nDatentypen\n\n\n\nTypname\nArt der Daten\n\n\n\n\ninteger\nganze Zahlen\n\n\nfloat\nGleitkommazahlen\n\n\nString\nZeichenketten\n\n\nBoolean\nWahrheitswert (True oder False)\n\n\nNoneType\nWert None\n\n\n\n\nprint(type(42))  # Integer (Ganzzahl)\nprint(type(3.14))  # Float (Gleitkommazahl)\nprint(type(\"Hallo\"))  # String (Text)\nprint(type(True), type(False))  # Boolean (Wahrheitswert)\nprint(type(None))  # NoneType (kein Wert)\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt; &lt;class 'bool'&gt;\n&lt;class 'NoneType'&gt;\n\n\n\n\nUmgang mit Strings\n\n\n\nOperation\nCode\n\n\n\n\nKonkatenation (Verkettung)\n\"Alice\" + \"Bob\"\n\n\nWiederholung\n\"Alice\" * 3\n\n\nNeue Zeile\n\"\\n\"\n\n\nUmwandeln in Großbuchstaben\n\"...\".upper()\n\n\nUmwandeln in Kleinbuchstaben\n\"...\".lower()\n\n\nLeerzeichen entfernen am Rand\n\"...\".strip()\n\n\n\n\nprint(\"Alice\" + \"Bob\") \nprint(\"Alice \" * 3)  \nprint(\"Hallo\\nWelt\") \nprint(\"mach mich groß\".upper())\nprint(\"MACH MICH KLEIN\".lower())\nprint(\"  zuschneiden bitte  \".strip())\n\nAliceBob\nAlice Alice Alice \nHallo\nWelt\nMACH MICH GROSS\nmach mich klein\nzuschneiden bitte\n\n\nMit f-Strings kann man Python-Ausdrücke in Strings einbetten. Alle Teile, die zwischen {...} eingeschlossen sind, werden als Python-Ausdrücke ausgewertet und das Ergebnis der Auswertung an dieser Stelle in den String eingefügt.\n\nprint(f\"2 + 2 = {2 + 2}\")\n\n2 + 2 = 4\n\n\nMit len(...) kann man die Länge eines Strings ermitteln.\n\ns = \"Guten Morgen!\"\nprint(len(s))\n\n13\n\n\n\n\nVariablen verwenden\nEine Variable ist wie eine “Schachtel” im Computerspeicher, wo man Daten ablegen kann. Weißt man einem Variablennamen mit = erstmals einen Wert zu, wird die entsprechende Variable im Computerspeicher angelegt.\nEine Variable mit Namen alter wird angelegt und mit dem Wert 15 belegt:\n\nalter = 15\n\nVerwendet man im Folgenden den Namen alter, wird auf den gespeicherten Wert zugegriffen:\n\nprint(alter)\nprint(alter + 5)\n\n15\n20\n\n\nVariablen haben einen Typ, der ihrem Inhalt entspricht:\n\nprint(type(alter))\n\n&lt;class 'int'&gt;\n\n\nDer Variablentyp kann sich ändern, wenn die Variable mit einem neuen Wert belegt wird:\n\nalter = 2.5\nprint(type(alter))\n\nalter = \"fünfzehn\"\nprint(type(alter))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nFür Variablennamen gelten folgende Regeln: - Dürfen nur Buchstaben, Zahlen und Unterstriche (_) enthalten - Dürfen nicht mit einer Zahl beginnen - Dürfen nur aus einem Wort bestehen (keine Leerzeichen)\nerlaubt z.B.: mein_name, alter2, _preis\nnicht erlaubt z.B.: 2alter, mein name, mein-name\n\n\nInput-Befehl\nDer Befehl input(\"...\") gibt den angegebenen String aus und wartet anschließend auf eine Eingabe des Benutzers. Die Eingabe wird als String-Wert dem Programm zurückgegeben und kann z.B. in einer Variable abgelegt werden.\nHier wird die Eingabe des Benutzers in der Variable name abgelegt:\nname = input(\"Wie heißt du?\")\n\nname = input(\"Wie heißt du? \") # Eingabe: Dornröschen\nprint(\"Hallo \" + name + \"!\")\n\n\n\nHallo Dornröschen!\n\n\nAchtung: input() gibt immer einen String zurück.\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nprint(type(eingabe))\n\n\n\n&lt;class 'str'&gt;\n\n\nDer eine Zahl enthaltende String kann aber in einen Zahltyp (int oder float) umgewandelt werden mit int(...) oder float(...).\n\neingabe = input(\"Gib eine Zahl ein: \") # Eingabe: 42\nzahl = int(eingabe)\nprint(type(zahl))\nprint(zahl + 5) \n\n\n\n&lt;class 'int'&gt;\n47\n\n\nAnalog kann man auch in float oder String umwandeln:\n\nvar = float(\"42.5\")\nprint(type(var))\nzahl = 17\nprint(type(str(zahl)))\n\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\n\nFormatierte Ausgabe mit f-Strings\nBei der Ausgabe mit f-Strings kann man Formatierungsvorgaben machen.\n\nname1 = \"Alice\"\nname2 = \"Bob\"\nname3 = \"Charlie\"\nalter1 = 15\nalter2 = 16\nalter3 = 18\ngroesse1 = 1.70\ngroesse2 = 1.85\ngroesse3 = 1.7382\n\nprint(\"Name     Alter   Größe\")\nprint(f\"{name1:8} {alter1:5d} {groesse1:7.2f}\")\nprint(f\"{name2:8} {alter2:5d} {groesse2:7.2f}\")\nprint(f\"{name3:8} {alter3:5d} {groesse3:7.2f}\")\n\nName     Alter   Größe\nAlice       15    1.70\nBob         16    1.85\nCharlie     18    1.74\n\n\nMöglichkeiten der Formatierung:\n\n\n\n\n\n\n\nFormat\nBedeutung\n\n\n\n\n:8\nmindestens 8 Zeichen breit, rechtsbündig (Standard)\n\n\n:5d\nmindestens 5 Zeichen breit, rechtsbündig, Integer (d = decimal)\n\n\n:7.2f\nmindestens 7 Zeichen breit, rechtsbündig, Fließkommazahl (f = float) mit 2 Nachkommastellen\n\n\n\nEs gibt viele weitere Formatierungsmöglichkeiten. Eine vollständige Übersicht findet man in der Python-Dokumentation:https://docs.python.org/3/library/string.html#formatspec"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html",
    "href": "pk-programmieren/03-Funktionen.html",
    "title": "Funktionen",
    "section": "",
    "text": "print(...) oder input(...) oder len(...) sind Beispiele für (bereits vorhandene) Funktionen in Python. Man benutzt Funktionen immer auf die gleiche Weise: Man schreibt den Funktionsnamen und in runden Klammern die sog. Argumente, die der Funktion mitgegeben werden.\nWas bedeutet die Formulierung “liefert … zurück” genau? Liefert eine Funktion ein Ergebnis zurück, so wird im Python-Ausdruck an der Stelle, an der die Funktion aufgerufen wird, das zurückgelieferte Ergebnis eingesetzt. Beispiel:\nDie Funktion len(\"Hallo\")+3 liefert den Wert 5 zurück. Damit wird aus dem Ausdruck len(\"Hallo\")+3 wird 5+3 und schließlich 8.\nDie Anzahl der übergebenen Argumente (auch Parameter genannt) ist unterschiedlich: es gibt Funktionen ohne Argument, mit einem Argument oder mit mehreren Argumenten. Beim Aufruf einer Funktion ohne Argument müssen trotzdem runde Klammern geschrieben werden, z.B.:"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "href": "pk-programmieren/03-Funktionen.html#definition-einer-funktion",
    "title": "Funktionen",
    "section": "Definition einer Funktion",
    "text": "Definition einer Funktion\nMan kann in Python eigene Funktionen definieren. Beispiel:\n\ndef schreibeHallo():\n    print(\"Hallo!\")\n    print(\"Heute ist ein schöner Tag, oder nicht?\")\n\nBei der Definition wird ein eingerückter Codeblock verwendet, analog zu den Codeblöcken, die in der Ablaufsteuerung bei if oder while verwendet werden.\nNun kann die so definierte Funktion schreibeHallo() wie alle anderen Python-Funktionen benutzt werden:\n\nprint(\"irgendein anderer Text\")\nschreibeHallo()\nprint(\"noch mehr Text\")\n\nirgendein anderer Text\nHallo!\nHeute ist ein schöner Tag, oder nicht?\nnoch mehr Text\n\n\nDie Funktion schreibeHallo() wurde ohne Argumente definiert. In diesem Fall darf man auch keines verwenden.\n\nschreibeHallo(\"Peter\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 schreibeHallo(\"Peter\")\n\nTypeError: schreibeHallo() takes 0 positional arguments but 1 was given"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "href": "pk-programmieren/03-Funktionen.html#funktionsdefinition-mit-argumenten",
    "title": "Funktionen",
    "section": "Funktionsdefinition mit Argumenten",
    "text": "Funktionsdefinition mit Argumenten\nArgumente kann man bei der Definition der Funktion in den runden Klammern angeben. Dabei darf man beliebige Variablennamen verwenden.\n\ndef schreibeHallo(name):\n    print(f\"Hallo, {name}!\")\n    laenge = len(name)\n    print(f\"Dein Name ist {laenge} Buchstaben lang.\")\n\nJetzt hat schreibeHallo einen Parameter. Der muss beim Aufruf auch angegeben werden.\n\nschreibeHallo(\"Egon\")\nschreibeHallo(\"Walburga\")\nschreibeHallo()\n\nHallo, Egon!\nDein Name ist 4 Buchstaben lang.\nHallo, Walburga!\nDein Name ist 8 Buchstaben lang.\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 3\n      1 schreibeHallo(\"Egon\")\n      2 schreibeHallo(\"Walburga\")\n----&gt; 3 schreibeHallo()\n\nTypeError: schreibeHallo() missing 1 required positional argument: 'name'\n\n\n\nDie Bezeichnung name für das Argument ist eine interne Bezeichnung, die nur in der Funktionsdefinition Bedeutung hat. Außerhalb der Definition spielt diese Bezeichnung keine Rolle.\n\nmeinVorname = \"Ignatius\"\nschreibeHallo(meinVorname)\n\nHallo, Ignatius!\nDein Name ist 8 Buchstaben lang.\n\n\nMan kann auch Funktionen mit mehreren Argumenten definieren:\n\ndef schreibeHallo(name, alter):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)\nschreibeHallo(\"Anna\", 30)\nschreibeHallo(\"Opa\", 70)\n\nHi Max!\nHallo, Anna!\nGuten Tag, Opa!"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "href": "pk-programmieren/03-Funktionen.html#rückgabewerte",
    "title": "Funktionen",
    "section": "Rückgabewerte",
    "text": "Rückgabewerte\nSelbst definierte Funktionen können ebenso wie z.B. len(...) Rückgabewerte haben. Dazu verwendet man in der Funktionsdefinition die Anweisung return. Dahinter wird der Rückgabewert angegeben.\n\ndef rechteckFlaeche(breite, hoehe):\n    flaeche = breite * hoehe\n    return flaeche\n\nDie Verwendung funktioniert wie bei anderen Funktionen mit Rückgabewert auch:\n\nb = 5\nh = 10\nA = rechteckFlaeche(b, h)\nprint(f\"Die Fläche des Rechtecks mit Breite {b} und Höhe {h} ist {A}.\")\n\nDie Fläche des Rechtecks mit Breite 5 und Höhe 10 ist 50.\n\n\nMan kann in der Definition mehrere return-Anweisungen verwenden. Die Ausführung der Funktion endet mit der ersten return-Anweisung, die ausgeführt wird.\n\ndef rechteckFlaeche(breite, hoehe):\n    if breite &lt; 0 or hoehe &lt; 0:\n        return \"Ungültige Eingabe: Breite und Höhe müssen positiv sein.\"\n    flaeche = breite * hoehe\n    return flaeche\n\n\nprint(rechteckFlaeche(5, 10))\nprint(rechteckFlaeche(-5, 10))\n\n50\nUngültige Eingabe: Breite und Höhe müssen positiv sein."
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "href": "pk-programmieren/03-Funktionen.html#keyword-argumente",
    "title": "Funktionen",
    "section": "keyword-Argumente",
    "text": "keyword-Argumente\nIm Normalfall werden die Argumente einer Funktion in der Reihenfolge übergeben, wie sie in der Funktionsdefinition angegeben. In der Funktionsdefinition im Beispiel oben\ndef schreibeHallo(name, alter):\nist der erste Parameter name, der zweite alter. Die Reihenfolge, in der die Argumente beim Aufruf angegeben werden, muss dieser Reihenfolge entsprechen.\nDavon unterscheiden sich die sogenannten keyword-Argumente. Dabei bekommen die einzelnen Argumente Namen, die beim Aufruf der Funktion mit angegeben werden mussen. Dadurch kann die Reihenfolge der Argumente beim Aufruf geändert werden.\nDie obige Beispielfunktion schreibeHallo kann auch so aufgerufen werden:\n\nschreibeHallo(alter=14, name=\"Max\")\n\nHi Max!\n\n\nHier werden die Argumente name und alter explizit benannt. Dadurch ist die Reihenfolge der Argumente beim Aufruf egal.\nMan darf keyword-Argumente und normale Argumente auch mischen. Dabei müssen die normalen Argumente zuerst angegeben werden, danach die keyword-Argumente.\n\nschreibeHallo(\"Max\", alter=14)\n\nHi Max!\n\n\nVerwendet man nach einem keyword-Argument ein nicht-keyword-Argument, so führt das zu einem Fehler:\n\nschreibeHallo(name=\"Max\", alter)\n\n\n  Cell In[15], line 1\n    schreibeHallo(name=\"Max\", alter)\n                                   ^\nSyntaxError: positional argument follows keyword argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "href": "pk-programmieren/03-Funktionen.html#optionale-argumente-und-default-werte",
    "title": "Funktionen",
    "section": "optionale Argumente und default-Werte",
    "text": "optionale Argumente und default-Werte\nEs ist möglich, in der Funktionsdefinition für Argumente default-Werte anzugeben. Diese Werte werden verwendet, wenn beim Aufruf der Funktion kein entsprechendes Argument angegeben wird.\n\ndef schreibeHallo(name, alter=30):\n    if alter &lt; 18:\n        print(f\"Hi {name}!\")\n    elif alter &lt; 65:\n        print(f\"Hallo, {name}!\")\n    else:\n        print(f\"Guten Tag, {name}!\")\n\n\nschreibeHallo(\"Max\", 14)   # alter wird mit 14 belegt\nschreibeHallo(\"Anna\")      # alter wird mit default-Wert 30 belegt\n\nHi Max!\nHallo, Anna!\n\n\nMan kann auch mehr als ein Argument mit einem default-Wert versehen.\ndef schreibeHallo(name=\"John\", alter=30):\n    ...\n\nschreibeHallo(\"Max\")\nschreibeHallo()\n\nHallo, Max!\nHallo, John!\n\n\nGibt es Argumente ohne default-Wert, müssen diese bei der Definition vor den Argumenten mit default-Wert angegeben werden. Folgendes führt zu einem Fehler:\ndef schreibeHallo(name=\"John\", alter):\n    ...\n\n\n\n  Cell In[20], line 1\n    def schreibeHallo(name=\"John\", alter):\n                                   ^\nSyntaxError: non-default argument follows default argument"
  },
  {
    "objectID": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "href": "pk-programmieren/03-Funktionen.html#lokaler-und-globaler-scope",
    "title": "Funktionen",
    "section": "lokaler und globaler Scope",
    "text": "lokaler und globaler Scope"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html",
    "href": "11imp/UebCollatzLsg.html",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "",
    "text": "Die Prüfung, ob a_n gerade oder ungerade ist, wird am besten mit dem Modulo-Operator % durchgeführt. Der Ausdruck a_n % 2 liefert den Rest der Division von a_n durch 2. Wenn dieser Rest 0 ist, ist die Zahl gerade, andernfalls ungerade.\n\ndef collatz_next(a_n):\n    if a_n % 2 == 0:\n        return a_n // 2\n    else:\n        return 3 * a_n + 1"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe",
    "href": "11imp/UebCollatzLsg.html#aufgabe",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "",
    "text": "Die Prüfung, ob a_n gerade oder ungerade ist, wird am besten mit dem Modulo-Operator % durchgeführt. Der Ausdruck a_n % 2 liefert den Rest der Division von a_n durch 2. Wenn dieser Rest 0 ist, ist die Zahl gerade, andernfalls ungerade.\n\ndef collatz_next(a_n):\n    if a_n % 2 == 0:\n        return a_n // 2\n    else:\n        return 3 * a_n + 1"
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe-1",
    "href": "11imp/UebCollatzLsg.html#aufgabe-1",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "2. Aufgabe",
    "text": "2. Aufgabe\n\ndef collatz_sequence(start_value):\n    a_n = start_value\n    while a_n != 1:\n        print(a_n)\n        a_n = collatz_next(a_n)\n    print(a_n)\n\nEs wäre auch möglich, anstelle der lokalen Variable a_n direkt mit start_value zu arbeiten. Die abschließende print(a_n)-Anweisung ist notwendig, um die 1 am Ende der Folge auch noch auszugeben."
  },
  {
    "objectID": "11imp/UebCollatzLsg.html#aufgabe-2",
    "href": "11imp/UebCollatzLsg.html#aufgabe-2",
    "title": "Übung: Programmieren einer Folge in Python – Lösung",
    "section": "3. Aufgabe",
    "text": "3. Aufgabe\n\ndef collatz_length(start_value):\n    a_n = start_value\n    length = 1  # Startwert zählt als erstes Glied\n    while a_n != 1:\n        a_n = collatz_next(a_n)\n        length += 1\n    return length\n\nDer Ansatz entspricht dem der vorherigen Aufgabe, nur wird hier keine Ausgabe erzeugt, sondern statt dessen eine Zählvariable length verwendet, die bei jedem Schritt um 1 erhöht wird. Am Ende wird die Länge der Folge zurückgegeben."
  },
  {
    "objectID": "11imp/11imp.html",
    "href": "11imp/11imp.html",
    "title": "IMP Klasse 11",
    "section": "",
    "text": "Lösungen\n\nÜbung: Programmieren einer Folge in Python\nÜbungen zu diskretem Wachstum\n\n\n\nPython\n\nEinführung in Python"
  },
  {
    "objectID": "11imp/UebWachstumLsg.html",
    "href": "11imp/UebWachstumLsg.html",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "",
    "text": "Umformen ergibt: \\[\na_{n+1} = 0.75\\cdot a_n + 100 = a_n - 0.25\\cdot a_n + 100 = a_n + 0.25\\cdot\\left(400 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 400\\) und der Wachstumsfaktor \\(k = 0.25\\).\n\n\n\nUmformen: \\[\na_{n+1} = 0.75\\cdot a_n + 100 \\; \\Rightarrow \\; a_n = \\frac{a_{n+1} - 100}{0.75}\n\\]\n\ndef berechneVorgaenger(an):\n    return (an - 100) / 0.75\n\nn = 10\nan = 381.1\nprint(f\"a_{n} = {an}\")\nwhile n &gt; 0:\n    an = berechneVorgaenger(an)\n    n -= 1\n    print(f\"a_{n} = {an:.2f}\")\n\na_10 = 381.1\na_9 = 374.80\na_8 = 366.40\na_7 = 355.20\na_6 = 340.27\na_5 = 320.36\na_4 = 293.81\na_3 = 258.41\na_2 = 211.21\na_1 = 148.28\na_0 = 64.38\n\n\nDer Startwert ist also \\(a_0 \\approx 64.38\\)."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe",
    "href": "11imp/UebWachstumLsg.html#aufgabe",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "",
    "text": "Umformen ergibt: \\[\na_{n+1} = 0.75\\cdot a_n + 100 = a_n - 0.25\\cdot a_n + 100 = a_n + 0.25\\cdot\\left(400 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 400\\) und der Wachstumsfaktor \\(k = 0.25\\).\n\n\n\nUmformen: \\[\na_{n+1} = 0.75\\cdot a_n + 100 \\; \\Rightarrow \\; a_n = \\frac{a_{n+1} - 100}{0.75}\n\\]\n\ndef berechneVorgaenger(an):\n    return (an - 100) / 0.75\n\nn = 10\nan = 381.1\nprint(f\"a_{n} = {an}\")\nwhile n &gt; 0:\n    an = berechneVorgaenger(an)\n    n -= 1\n    print(f\"a_{n} = {an:.2f}\")\n\na_10 = 381.1\na_9 = 374.80\na_8 = 366.40\na_7 = 355.20\na_6 = 340.27\na_5 = 320.36\na_4 = 293.81\na_3 = 258.41\na_2 = 211.21\na_1 = 148.28\na_0 = 64.38\n\n\nDer Startwert ist also \\(a_0 \\approx 64.38\\)."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-1",
    "href": "11imp/UebWachstumLsg.html#aufgabe-1",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "2. Aufgabe",
    "text": "2. Aufgabe\n\na)\nRekursionsvorschrift: \\(a_{n+1} = .998\\cdot a_n + 1000\\) mit \\(a_0 = 0\\).\n\n\n\n\n\n\nHinweis\n\n\n\nIn der Aufgabenstellung ist nicht ganz eindeutig formuliert, ob zuerst die 0,2% verdunsten und dann die 1000 m3 hinzukommen oder umgekehrt. Je nachdem, wie man die Aufgabe interpretiert, ist auch die folgende Rekursionsvorschrift möglich: \\[a_{n+1} = .998\\cdot (a_n + 1000)\\]\nDiese Problematik ist eine Folge der Modellierung als diskretes Wachstum, obwohl es sich eigentlich um einen kontinuierlichen Prozess handelt.\n\n\n\n\nb)\nUmformen ergibt: \\[\na_{n+1} = .998\\cdot a_n + 1000 = a_n - 0.002\\cdot a_n + 1000 = a_n + 0.002\\cdot\\left(500000 - a_n\\right)\n\\]\nDie Schranke ist damit \\(S = 500000\\) und der Wachstumsfaktor \\(k = 0.002\\).\n\n\nc)\n\ndef berechneNachfolger(an):\n    return 0.998 * an + 1000\n\nn = 0\nan = 0\nwhile an &lt; 0.25 * 500000:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Stunden sind {an:.0f} m³ im See, d.h. er ist zu {an/500000*100:.0f}% gefüllt.\")\n\nNach 144 Stunden sind 125227 m³ im See, d.h. er ist zu 25% gefüllt."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-2",
    "href": "11imp/UebWachstumLsg.html#aufgabe-2",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "3. Aufgabe",
    "text": "3. Aufgabe\n\na)\nDer Ansatz ist ein logistisches Wachstum, d.h. \\[\na_{n+1} = a_n + k\\cdot a_n\\cdot\\left(S - a_n\\right)\n\\]\nAus der Aufgabenstellung ergibt sich \\(S=9.00\\) und \\(a_0 = 0.2\\). Nach einer Woche ist \\(a_1 = 0.4\\). Damit gilt:\n\\[\n0.4 = 0.2 + k\\cdot 0.2\\cdot(9.00 - 0.2) \\;\\Rightarrow\\; k = \\frac{0.2}{0.2\\cdot 8.8} = \\frac{1}{8.8} \\approx 0.1136\n\\]\n\n\nb)\n\ndef berechneNachfolger(an):\n    return an + 0.1136 * an * (9.00 - an)\n\nn = 0\nan = 0.2\nwhile n &lt; 8:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Wochen ist die Pflanzenhöhe {an:.2f} m.\")\n\nNach 8 Wochen ist die Pflanzenhöhe 8.99 m.\n\n\n\n\nc)\n\ndef berechneNachfolger(an):\n    return an + 0.1136 * an * (9.00 - an)\n\nn = 0\nan = 0.2\nwhile an &lt; 8:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Wochen ist die Pflanzenhöhe {an:.2f} m und damit erstmalig über 8 m.\")\n\nNach 7 Wochen ist die Pflanzenhöhe 8.63 m und damit erstmalig über 8 m."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-3",
    "href": "11imp/UebWachstumLsg.html#aufgabe-3",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "4. Aufgabe",
    "text": "4. Aufgabe\n\na)\nAnsatz mit beschränktem Wachstum: \\[\na_{n+1} = a_n + k\\cdot\\left(S - a_n\\right)\n\\]\nAus der Aufgabenstellung ergibt sich \\(S=30\\) und \\(a_0 = 6\\). Nach 1 Minute ist \\(a_1 = 7.2\\). Damit gilt:\n\\[\n7.2 = 6 + k\\cdot(30 - 6) \\;\\Rightarrow\\; k = \\frac{1.2}{24} = 0.05\n\\]\n\n\nb)\n\ndef berechneNachfolger(an):\n    return an + 0.05 * (30 - an)\n\nn = 0\nan = 6\nwhile an &lt; 20:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Minuten ist die Temperatur {an:.2f} °C.\")\n\nNach 18 Minuten ist die Temperatur 20.47 °C."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-4",
    "href": "11imp/UebWachstumLsg.html#aufgabe-4",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "5. Aufgabe",
    "text": "5. Aufgabe\n\na) und b)\nEs handelt sich um ein exponentielles Wachstum mit der Rekursionsvorschrift \\(a_{n+1} = q\\cdot a_n\\). Aus der Aufgabenstellung ergibt sich \\(q = (0.5)^{0.2} \\approx 0.87055\\).\n\n\n\n\n\n\nHinweis\n\n\n\nBegründung:\nNach 5 Tagen ist die Hälfte zerfallen, d.h. \\(a_5 = \\frac 12 \\cdot a_0\\). Andererseits gilt \\(a_5 = q^5 \\cdot a_0\\). Also ist \\(q^5 = \\frac 12\\) und damit \\(q = \\left(\\frac 12\\right)^{\\frac 15}\\).\n\n\n\ndef berechneNachfolger(an):\n    return 0.87055 * an\n\nn = 0\nan = 100\nprint(f\"Tag {n}: {an} mg\")\nwhile n &lt; 10:\n    an = berechneNachfolger(an)\n    n += 1\n    print(f\"Tag {n}: {an:.2f} mg\")\n\nTag 0: 100 mg\nTag 1: 87.06 mg\nTag 2: 75.79 mg\nTag 3: 65.98 mg\nTag 4: 57.43 mg\nTag 5: 50.00 mg\nTag 6: 43.53 mg\nTag 7: 37.89 mg\nTag 8: 32.99 mg\nTag 9: 28.72 mg\nTag 10: 25.00 mg\n\n\n\n\nc)\n\ndef berechneNachfolger(an):\n    return 0.87055 * an\n\nn = 0\nan = 100\nwhile an &gt;= .01:\n    an = berechneNachfolger(an)\n    n += 1\nprint(f\"Nach {n} Tagen sind noch {an:.3f} mg übrig.\")\n\nNach 67 Tagen sind noch 0.009 mg übrig."
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-5",
    "href": "11imp/UebWachstumLsg.html#aufgabe-5",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "6. Aufgabe",
    "text": "6. Aufgabe\n\na)\n\nguthaben_bank1 = 1000\nguthaben_bank2 = 1000\nguthaben_bank3 = 1000\nguthaben_bank4 = 1000\n\nmonat = 0\nwhile monat &lt; 6*12:\n    monat += 1\n    guthaben_bank3 = guthaben_bank3*1.002\n    if monat % 12 == 0:\n        guthaben_bank1 += 1000*0.024\n        guthaben_bank2 = guthaben_bank2*1.023\n        if monat &lt;= 2*12:\n            guthaben_bank4 = guthaben_bank4*1.006\n        elif monat &lt;= 4*12:\n            guthaben_bank4 = guthaben_bank4*1.012\n        else:\n            guthaben_bank4 = guthaben_bank4*1.07\n        print(f\"Ende Monat {monat}: {guthaben_bank1:.2f} €, {guthaben_bank2:.2f} €, {guthaben_bank3:.2f} €, {guthaben_bank4:.2f} €\")\n\nEnde Monat 12: 1024.00 €, 1023.00 €, 1024.27 €, 1006.00 €\nEnde Monat 24: 1048.00 €, 1046.53 €, 1049.12 €, 1012.04 €\nEnde Monat 36: 1072.00 €, 1070.60 €, 1074.58 €, 1024.18 €\nEnde Monat 48: 1096.00 €, 1095.22 €, 1100.65 €, 1036.47 €\nEnde Monat 60: 1120.00 €, 1120.41 €, 1127.36 €, 1109.02 €\nEnde Monat 72: 1144.00 €, 1146.18 €, 1154.72 €, 1186.66 €\n\n\n\n\nb)\n\nBank 1: lineares Wachstum\nBank 2: exponentielles Wachstum\nBank 3: exponentielles Wachstum\nBank 4: sonstige Wachstumsform (stückweise exponentielles Wachstum)"
  },
  {
    "objectID": "11imp/UebWachstumLsg.html#aufgabe-7",
    "href": "11imp/UebWachstumLsg.html#aufgabe-7",
    "title": "Übungen zu diskretem Wachstum – Lösungen",
    "section": "Aufgabe 7",
    "text": "Aufgabe 7\n\na)\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    if monat % 12 == 0:\n        darlehen = darlehen * 1.03\n    if monat %12 == 1:\n        if darlehen &gt;= 18000:\n            darlehen -= 18000\n            bezahlt += 18000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 265 Monaten ist das Darlehen getilt.\nInsgesamt wurde 404679.12 € bezahlt.\n\n\n\n\nb)\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    darlehen *= 1.0025\n    if darlehen &gt; 1500:\n        darlehen -= 1500\n        bezahlt += 1500\n    else:\n        bezahlt += darlehen\n        darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 278 Monaten ist das Darlehen getilt.\nInsgesamt wurde 416408.40 € bezahlt.\n\n\n\n\nc)\nFall a):\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    if monat % 12 == 0:\n        darlehen = darlehen * 1.03\n    if monat %12 == 1:\n        if darlehen &gt;= 18000:\n            darlehen -= 18000\n            bezahlt += 18000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n    if monat%24 == 1:\n        if darlehen &gt;= 6000:\n            darlehen -= 6000\n            bezahlt += 6000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 217 Monaten ist das Darlehen getilt.\nInsgesamt wurde 381206.46 € bezahlt.\n\n\nFall b):\n\ndarlehen = 300000\nmonat = 0\nbezahlt = 0\nwhile darlehen &gt; 0:\n    monat += 1\n    darlehen *= 1.0025\n    if darlehen &gt; 1500:\n        darlehen -= 1500\n        bezahlt += 1500\n    else:\n        bezahlt += darlehen\n        darlehen = 0\n    if monat%24 == 1:\n        if darlehen &gt;= 6000:\n            darlehen -= 6000\n            bezahlt += 6000\n        else:\n            bezahlt += darlehen\n            darlehen = 0\n\nprint(f\"Nach {monat} Monaten ist das Darlehen getilt.\")\nprint(f\"Insgesamt wurde {bezahlt:.2f} € bezahlt.\")\n\nNach 221 Monaten ist das Darlehen getilt.\nInsgesamt wurde 390041.04 € bezahlt."
  },
  {
    "objectID": "pk-programmieren/pk-prog_einfPython.html",
    "href": "pk-programmieren/pk-prog_einfPython.html",
    "title": "Einführung in Python",
    "section": "",
    "text": "1. Grundlagen\n2. Flow control\n3. Funktionen"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html",
    "href": "pk-programmieren/02-flow-control.html",
    "title": "Flow control",
    "section": "",
    "text": "In Programmen hat man oft “wenn … dann …” Situationen. Im “wenn”-Teil steht eine Bedingung, die entweder wahr (True) oder falsch (False) ist. Diese Bedingungen werden in Python mit boolschen Ausdrücken dargestellt.\nHäufig ergeben sich boolsche Ausdrücke mit Vergleichsoperatoren.\nprint(f\"5 == 5 ist {5 == 5}\") \nprint(f\"5 == 3 ist {5 == 3}\") \n\nprint(f\"5 != 3 ist {5 != 3}\") \nprint(f\"5 != 5 ist {5 != 5}\")\n\nprint(f\"3 &lt; 5 ist {3 &lt; 5}\")\nprint(f\"5 &lt; 5 ist {5 &lt; 5}\")\n\n5 == 5 ist True\n5 == 3 ist False\n5 != 3 ist True\n5 != 5 ist False\n3 &lt; 5 ist True\n5 &lt; 5 ist False\nVergleiche funktionieren auch mit Variablen:\na = 10\nb = 20\nprint(f\"Für a = {a} und b = {b} ist a &lt; b {a &lt; b}.\")\n\nFür a = 10 und b = 20 ist a &lt; b True.\nMan kann boolsche Werte in Variablen abspeichern:\nvergleich1 = 5 &gt; 3\nvergleich2 = 3 &lt; 1\nprint(f\"vergleich1 ist {vergleich1}, vergleich2 ist {vergleich2}\")\n\nvergleich1 ist True, vergleich2 ist False\nBoolsche Ausdrücke können mit logischen Operatoren kombiniert werden.\nprint(f\"(5 &gt; 3) and (3 &lt; 1): {(5 &gt; 3) and (3 &lt; 1)}\")  \nprint(f\"(5 &gt; 3) and (3 &gt; 1): {(5 &gt; 3) and (3 &gt; 1)}\")  \nprint(f\"(5 &gt; 3) or (3 &lt; 1): {(5 &gt; 3) or (3 &lt; 1)}\")  \nprint(f\"(5 &lt; 3) or (3 &lt; 1): {(5 &lt; 3) or (3 &lt; 1)}\")  \nprint(f\"not (5 &gt; 3): {not (5 &gt; 3)}\")  \nprint(f\"not (5 &lt; 3): {not (5 &lt; 3)}\")  \n\n(5 &gt; 3) and (3 &lt; 1): False\n(5 &gt; 3) and (3 &gt; 1): True\n(5 &gt; 3) or (3 &lt; 1): True\n(5 &lt; 3) or (3 &lt; 1): False\nnot (5 &gt; 3): False\nnot (5 &lt; 3): True\nBesonderheiten: int- und float-Typen können untereinander verglichen werden, String-Ausdrücke können nicht mit Zahlentypen verglichen werden. Jedoch können Strings untereinander verglichen werden.\nprint(f\"5 == 5.0: {5 == 5.0}\")\nprint(f\"5 == '5': {5 == '5'}\")\nprint(f\"'Hallo' == 'Hallo': {'Hallo' == 'Hallo'}\")\n\n5 == 5.0: True\n5 == '5': False\n'Hallo' == 'Hallo': True"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#if-anweisung",
    "href": "pk-programmieren/02-flow-control.html#if-anweisung",
    "title": "Flow control",
    "section": "if-Anweisung",
    "text": "if-Anweisung\nDie if-Anweisung wird verwendet, um Code nur dann auszuführen, wenn eine bestimmte Bedingung erfüllt ist. Ist die Bedingung wahr (True), wird der eingerückte Codeblock ausgeführt. Ist sie falsch (False), wird der Codeblock übersprungen.\nDie Syntax lautet:\nif [boolscher Ausdruck]:\n    ...\n    ...\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nIn diesem Beispiel wird die Ausgabe nur angezeigt, wenn a tatsächlich kleiner als b ist.\n\na = 5\nb = 10\nif a &lt; b:\n    print(\"a ist kleiner als b\")\n\nif b == a:\n    print(\"b ist gleich a\")\n\na ist kleiner als b\n\n\nDie else-Anweisung wird verwendet, um einen Codeblock auszuführen, wenn die Bedingung der vorherigen if-Anweisung nicht erfüllt ist. Sie ergänzt die if-Anweisung und sorgt dafür, dass genau einer der beiden Blöcke ausgeführt wird.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\nIn diesem Beispiel wird die Ausgabe im else-Block nur angezeigt, wenn die Bedingung a &lt; b falsch ist.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelse:\n    print(\"a ist nicht kleiner als b\")\n\na ist nicht kleiner als b\n\n\nDie elif-Anweisung steht für “else if” und wird verwendet, um mehrere Bedingungen in einer if-else-Struktur zu überprüfen. Sie folgt auf eine if-Anweisung und vor einer optionalen else-Anweisung. Sobald eine Bedingung wahr ist, wird der zugehörige Codeblock ausgeführt und die restlichen Bedingungen werden übersprungen.\nBeispiel:\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\nMit elif können also mehrere Alternativen übersichtlich hintereinander geprüft werden.\n\na = 10\nb = 5\nif a &lt; b:\n    print(\"a ist kleiner als b\")\nelif a == b:\n    print(\"a ist gleich b\")\nelse:\n    print(\"a ist größer als b\")\n\na ist größer als b\n\n\nAchtung: Sobald eine elif-Bedingung richtig ist, wird der Rest nicht mehr geprüft:\n\na = 1000\nb = 5\nif a &gt; b:\n    print(\"a ist größer als b\")\nelif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist größer als b\n\n\nÄndert man die Reihenfolge, funktioniert es:\n\na = 1000\nb = 5\nif a &gt; b + 100:\n    print(\"a ist viel größer als b\")\nelif a &gt; b:\n    print(\"a ist größer als b\")\nelse:\n    print(\"a ist nicht größer als b\")\n\na ist viel größer als b"
  },
  {
    "objectID": "pk-programmieren/02-flow-control.html#while-schleifen",
    "href": "pk-programmieren/02-flow-control.html#while-schleifen",
    "title": "Flow control",
    "section": "While-Schleifen",
    "text": "While-Schleifen\nDie while-Schleife wird verwendet, um einen Codeblock so lange zu wiederholen, wie eine bestimmte Bedingung wahr (True) ist. Die Bedingung wird vor jedem Durchlauf überprüft. Sobald sie falsch (False) wird, endet die Schleife. Die Syntax ist:\nwhile [boolscher Ausdruck]:\n    ...\n    ...\n\neingabe = int(input(\"Was ist 5 + 3? \")) # Eingabe: 7\nwhile eingabe != 8:\n    print(\"Falsch! Versuch es noch einmal.\")\n    eingabe = int(input(\"Was ist 5 + 3? \")) # Einfabe: 8\nprint(\"Richtig!\")\n\n\n\nWas ist 5 + 3? 7\nFalsch! Versuch es noch einmal.\nWas ist 5 + 3? 8\nRichtig!\n\n\nWir suchen durch Ausprobieren die kleinste Zahl, die durch 18 und 12 teilbar ist:\n\nzahl = 1\nwhile (zahl % 18 != 0) or (zahl % 12 != 0):\n    zahl = zahl + 1\nprint(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie break-Anweisung wird verwendet, um eine Schleife vorzeitig zu beenden. Sobald break im Schleifen-Block ausgeführt wird, wird die Schleife sofort verlassen und das Programm läuft mit dem Code nach der Schleife weiter.\nTypischerweise wird break eingesetzt, wenn eine bestimmte Bedingung innerhalb der Schleife erfüllt ist und keine weiteren Durchläufe mehr nötig sind.\nBeispiel von oben in abgeänderter Form:\n\nzahl = 1\nwhile True:\n    if (zahl % 18 == 0) and (zahl % 12 == 0):\n        print(f\"Die kleinste Zahl, die durch 18 und 12 teilbar ist, ist {zahl}.\")\n        break\n    zahl = zahl + 1\n\nDie kleinste Zahl, die durch 18 und 12 teilbar ist, ist 36.\n\n\nDie continue-Anweisung springt wieder zum Beginn der Schleife, der Rest der Anweisung wird für diesen Durchgang ausgelassen.\n\nwhile True:\n    name = input(\"Wer bist du? \") # Eingabe: Master, danach: Doctor\n    if name != \"Doctor\":\n        continue\n    print(\"Hallo Doctor! Was ist das Passwort?\")\n    passwort = input(\"Passwort: \") # Eingabe: Tardis\n    if passwort == \"Tardis\":\n        break\nprint(\"Zutritt gewährt.\")\n\n\n\nWer bist du? Master\nWer bist du? Doctor\nHallo Doctor! Was ist das Passwort? Tardis\nZutritt gewährt."
  },
  {
    "objectID": "pk-programmieren/pk-prog.html",
    "href": "pk-programmieren/pk-prog.html",
    "title": "P-Kurs Programmieren",
    "section": "",
    "text": "Einführung in Python\nSkript\n\n\nLösungen zu den Aufgaben"
  }
]